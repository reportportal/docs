"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[3892],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>c});var i=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,i,a=function(e,n){if(null==e)return{};var t,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)t=r[i],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)t=r[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var p=i.createContext({}),s=function(e){var n=i.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},u=function(e){var n=s(e.components);return i.createElement(p.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},m=i.forwardRef((function(e,n){var t=e.components,a=e.mdxType,r=e.originalType,p=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),m=s(t),c=a,g=m["".concat(p,".").concat(c)]||m[c]||d[c]||r;return t?i.createElement(g,o(o({ref:n},u),{},{components:t})):i.createElement(g,o({ref:n},u))}));function c(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var r=t.length,o=new Array(r);o[0]=m;var l={};for(var p in n)hasOwnProperty.call(n,p)&&(l[p]=n[p]);l.originalType=e,l.mdxType="string"==typeof e?e:a,o[1]=l;for(var s=2;s<r;s++)o[s]=t[s];return i.createElement.apply(null,o)}return i.createElement.apply(null,t)}m.displayName="MDXCreateElement"},61182:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>l,toc:()=>s});var i=t(87462),a=(t(67294),t(3905));const r={},o="Plugin developers guide",l={unversionedId:"dev-guides/PluginDevelopersGuide",id:"dev-guides/PluginDevelopersGuide",title:"Plugin developers guide",description:"Introduction",source:"@site/docs/dev-guides/PluginDevelopersGuide.mdx",sourceDirName:"dev-guides",slug:"/dev-guides/PluginDevelopersGuide",permalink:"/docs/dev-guides/PluginDevelopersGuide",draft:!1,editUrl:"https://github.com/reportportal/documentation/docs/dev-guides/PluginDevelopersGuide.mdx",tags:[],version:"current",frontMatter:{},sidebar:"defaultSidebar",previous:{title:"Interactions between API and Analyzer",permalink:"/docs/dev-guides/InteractionsBetweenAPIAndAnalyzer"},next:{title:"ReportPortal API",permalink:"/docs/dev-guides/ReportPortalAPI"}},p={},s=[{value:"Introduction",id:"introduction",level:2},{value:"How does it work",id:"how-does-it-work",level:2},{value:"Creating your first plugin",id:"creating-your-first-plugin",level:2},{value:"Base plugin configuration",id:"base-plugin-configuration",level:3},{value:"Create extension",id:"create-extension",level:3},{value:"Autowire dependencies",id:"autowire-dependencies",level:3},{value:"Get file command",id:"get-file-command",level:3},{value:"Assemble plugin",id:"assemble-plugin",level:3},{value:"Event listeners",id:"event-listeners",level:3},{value:"Lazy initialization",id:"lazy-initialization",level:2},{value:"We create extension object using constructor and only then we autowire dependencies. If we don&#39;t use lazy initialization - all objects created in the constructor will be created with <code>NULL</code> objects that were marked as <code>@Autowired</code>",id:"we-create-extension-object-using-constructor-and-only-then-we-autowire-dependencies-if-we-dont-use-lazy-initialization---all-objects-created-in-the-constructor-will-be-created-with-null-objects-that-were-marked-as-autowired",level:5}],u={toc:s};function d(e){let{components:n,...r}=e;return(0,a.kt)("wrapper",(0,i.Z)({},u,r,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"plugin-developers-guide"},"Plugin developers guide"),(0,a.kt)("h2",{id:"introduction"},"Introduction"),(0,a.kt)("p",null,"ReportPortal as a microservice application had services that integrate with external systems like JIRA or RALLY. These are problems of this\napproach:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"every service will run as a separate application consuming additional amount of resources for environment;"),(0,a.kt)("li",{parentName:"ul"},"user may not need all the integrations at the moment but need some (or a new one) later, so he should modify deployment configuration\nevery time;"),(0,a.kt)("li",{parentName:"ul"},"every service modification requires re-deployment.")),(0,a.kt)("p",null,"To solve these problems and support dynamic integrations ReportPortal implements plugin system on top\nof ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/pf4j/pf4j"},"PF4J"),"."),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},(0,a.kt)("strong",{parentName:"p"},"NOTE:")," Documentation for the UI plugins can be found ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/reportportal/service-ui/blob/master/docs/14-plugins.md"},"here"))),(0,a.kt)("h2",{id:"how-does-it-work"},"How does it work"),(0,a.kt)("media-view",{src:t(11931),alt:"Install Plugin"}),(0,a.kt)("h2",{id:"creating-your-first-plugin"},"Creating your first plugin"),(0,a.kt)("p",null,"Result of the following steps can be found here - ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/reportportal/plugin-example"},"Plugin example"),".\nThis is fully configured and ready-to-use plugin"),(0,a.kt)("h3",{id:"base-plugin-configuration"},"Base plugin configuration"),(0,a.kt)("p",null,"We configure our build.gradle file as follows:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-groovy"},"plugins {\n    id \"io.spring.dependency-management\" version \"1.0.9.RELEASE\"\n    id 'java'\n}\n\nrepositories {\n    mavenCentral()\n}\n\ndependencies {\n    implementation 'com.epam.reportportal:plugin-api:5.4.0'\n    annotationProcessor 'com.epam.reportportal:plugin-api:5.4.0'\n}\n\ntask plugin(type: Jar) {\n    getArchiveBaseName().set(\"plugin-${pluginId}\")\n    into('classes') {\n        with jar\n    }\n    into('lib') {\n        from configurations.compile\n    }\n    extension('zip')\n}\n\ntask assemblePlugin(type: Copy) {\n    from plugin\n    into pluginsDir\n}\n\ntask assemblePlugins(type: Copy) {\n    dependsOn subprojects.assemblePlugin\n}\n")),(0,a.kt)("p",null,"This base configuration with ",(0,a.kt)("inlineCode",{parentName:"p"},"plugin-api")," dependency grants access to extension points and core ReportPortal dependencies."),(0,a.kt)("br",null),(0,a.kt)("h3",{id:"create-extension"},"Create extension"),(0,a.kt)("p",null,"Firstly we create our plugin representation (we also can override ",(0,a.kt)("inlineCode",{parentName:"p"},"start()")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"stop()")," methods) that will be managed by ",(0,a.kt)("inlineCode",{parentName:"p"},"pf4j")," plugin\nmanager."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},"package com.epam.reportportal.extension.example;\n\nimport org.pf4j.Plugin;\nimport org.pf4j.PluginWrapper;\n\npublic class ExamplePlugin extends Plugin {\n    public ExamplePlugin(PluginWrapper wrapper) {\n        super(wrapper);\n    }\n}\n")),(0,a.kt)("p",null,"Then we create our plugin entry point. We start with ",(0,a.kt)("inlineCode",{parentName:"p"},"ReportPortalExtensionPoint")," implementation:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},'\n@Extension\npublic class ExampleExtension implements ReportPortalExtensionPoint {\n\n    private final Supplier<Map<String, PluginCommand<?>>> pluginCommandMapping = new MemoizingSupplier<>(this::getCommands);\n\n    public ExampleExtension(Map<String, Object> initParams) {\n\n    }\n\n    @Override\n    public Map<String, ?> getPluginParams() {\n        Map<String, Object> params = new HashMap<>();\n        params.put(ALLOWED_COMMANDS, new ArrayList<>(pluginCommandMapping.get().keySet()));\n        return params;\n    }\n\n    @Override\n    public PluginCommand<?> getCommandToExecute(String commandName) {\n        return pluginCommandMapping.get().get(commandName);\n    }\n\n    private Map<String, PluginCommand<?>> getCommands() {\n        Map<String, PluginCommand<?>> pluginCommandMapping = new HashMap<>();\n        pluginCommandMapping.put("testConnection", (integration, params) -> true);\n        return pluginCommandMapping;\n    }\n}\n')),(0,a.kt)("p",null,"We implement ",(0,a.kt)("inlineCode",{parentName:"p"},"getPluginParams()")," to get list of supported plugin ",(0,a.kt)("inlineCode",{parentName:"p"},"commands")," from the client side. We implement ",(0,a.kt)("inlineCode",{parentName:"p"},"getCommandToExecute()")," to\nget command from mapping to execute. As for now we only have ",(0,a.kt)("inlineCode",{parentName:"p"},"testConnection")," command that implements base command interface:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},"public interface PluginCommand<T> {\n    /**\n     * Executes plugin command\n     *\n     * @param integration Configured ReportPortal integration\n     * @param params      Plugin Command parameters\n     * @return Result\n     */\n    T executeCommand(Integration integration, Map<String, Object> params);\n}\n")),(0,a.kt)("p",null,"Command ",(0,a.kt)("inlineCode",{parentName:"p"},"testConnection")," is mandatory and should either always return ",(0,a.kt)("inlineCode",{parentName:"p"},"true")," or execute logic of connection test with external system."),(0,a.kt)("br",null),(0,a.kt)("h3",{id:"autowire-dependencies"},"Autowire dependencies"),(0,a.kt)("p",null,"Being loaded in runtime plugin extension can be handled as ",(0,a.kt)("inlineCode",{parentName:"p"},"Spring bean"),". That's why we can autowire dependencies just as we do in core\napplication:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},"\n@Extension\npublic class ExampleExtension implements ReportPortalExtensionPoint {\n  ...\n    @Autowired\n    private ApplicationContext applicationContext;\n\n    @Autowired\n    private IntegrationTypeRepository integrationTypeRepository;\n\n    @Autowired\n    private IntegrationRepository integrationRepository;\n\n    public ExampleExtension(Map<String, Object> initParams) {\n    }\n  ...\n}      \n")),(0,a.kt)("br",null),(0,a.kt)("h3",{id:"get-file-command"},"Get file command"),(0,a.kt)("p",null,"We can store in ",(0,a.kt)("inlineCode",{parentName:"p"},"resources")," folder files that can be loaded from the client side later. During plugin installation ",(0,a.kt)("inlineCode",{parentName:"p"},"plugin manager")," provides\ndirectory in the file system to store plugin resources. This directory passed through the constructor (with Map parameter) and can be\naccessed as follows:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},'\n@Extension\npublic class ExampleExtension implements ReportPortalExtensionPoint {\n\n    private final String resourcesDir;\n\n    ...\n\n    public ExampleExtension(Map<String, Object> initParams) {\n        resourcesDir = IntegrationTypeProperties.RESOURCES_DIRECTORY.getValue(initParams).map(String::valueOf).orElse("");\n    }\n\n    ...\n}\n')),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"GetFileCommand")," accepts ",(0,a.kt)("inlineCode",{parentName:"p"},"resourcesDir")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"propertyFile")," as constructor parameters. Property file should be stored in ",(0,a.kt)("inlineCode",{parentName:"p"},"resources")," folder\nof the plugin. It contains ",(0,a.kt)("em",{parentName:"p"},"key-value")," mapping that represents files allowed to be loaded from the client side:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-properties"},"icon=plugin-icon.svg\n")),(0,a.kt)("p",null,"We created ",(0,a.kt)("inlineCode",{parentName:"p"},"example-binary-data.properties")," file with these contents and now can access ",(0,a.kt)("inlineCode",{parentName:"p"},"plugin-icon.svg")," file by passing ",(0,a.kt)("inlineCode",{parentName:"p"},"icon")," key\nto ",(0,a.kt)("inlineCode",{parentName:"p"},"getFileCommand"),"."),(0,a.kt)("p",null,"That's how our extension looks now:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},'\n@Extension\npublic class ExampleExtension implements ReportPortalExtensionPoint {\n\n    public static final String BINARY_DATA_PROPERTIES_FILE_ID = "example-binary-data.properties";\n    private final String resourcesDir;\n\n    private final Supplier<Map<String, PluginCommand<?>>> pluginCommandMapping = new MemoizingSupplier<>(this::getCommands);\n\n    @Autowired\n    private ApplicationContext applicationContext;\n\n    @Autowired\n    private IntegrationTypeRepository integrationTypeRepository;\n\n    @Autowired\n    private IntegrationRepository integrationRepository;\n\n    public ExampleExtension(Map<String, Object> initParams) {\n        resourcesDir = IntegrationTypeProperties.RESOURCES_DIRECTORY.getValue(initParams).map(String::valueOf).orElse("");\n    }\n\n    @Override\n    public Map<String, ?> getPluginParams() {\n        Map<String, Object> params = new HashMap<>();\n        params.put(ALLOWED_COMMANDS, new ArrayList<>(pluginCommandMapping.get().keySet()));\n        return params;\n    }\n\n    @Override\n    public PluginCommand<?> getCommandToExecute(String commandName) {\n        return pluginCommandMapping.get().get(commandName);\n    }\n\n    private Map<String, PluginCommand<?>> getCommands() {\n        Map<String, PluginCommand<?>> pluginCommandMapping = new HashMap<>();\n        pluginCommandMapping.put("getFile", new GetFileCommand(resourcesDir, BINARY_DATA_PROPERTIES_FILE_ID));\n        pluginCommandMapping.put("testConnection", (integration, params) -> true);\n        return pluginCommandMapping;\n    }\n}\n')),(0,a.kt)("br",null),(0,a.kt)("h3",{id:"assemble-plugin"},"Assemble plugin"),(0,a.kt)("p",null,"Our plugin can be built either as:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"simple jar (without external dependencies) and use dependencies from core application;"),(0,a.kt)("li",{parentName:"ul"},"shadow jar (with external dependencies) and still use dependencies from core application.")),(0,a.kt)("p",null,"We should configure plugin jar manifest with mandatory properties:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"id"),(0,a.kt)("li",{parentName:"ul"},"version"),(0,a.kt)("li",{parentName:"ul"},"plugin class (class marked with @Extension - our entry point)")),(0,a.kt)("p",null,"We should configure ",(0,a.kt)("inlineCode",{parentName:"p"},"resource")," folder contents handling."),(0,a.kt)("p",null,"As we load api plugin contents in runtime we can do so with ui contents too. To make it possible we should modify our configuration.\nWe provide new ",(0,a.kt)("inlineCode",{parentName:"p"},"ui.gradle")," config:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-groovy"},"node {\n    version = '10.14.1'\n    npmVersion = '6.4.1'\n    download = true\n    workDir = file(\"${project.buildDir}/ui\")\n    nodeModulesDir = file(\"${project.rootDir}/ui\")\n}\n\nnpm_run_build {\n    inputs.files fileTree(\"ui/src\")\n    inputs.file 'ui/package.json'\n    inputs.file 'ui/package-lock.json'\n    outputs.dir 'ui/build'\n}\n")),(0,a.kt)("p",null,"Load it to the main configuration as a dependency and make some changes to include generated ",(0,a.kt)("inlineCode",{parentName:"p"},"main.js")," file to ",(0,a.kt)("inlineCode",{parentName:"p"},"resources")," folder that\nallows us to load it using ",(0,a.kt)("inlineCode",{parentName:"p"},"GetFileCommand"),"."),(0,a.kt)("p",null,"That's how our ",(0,a.kt)("inlineCode",{parentName:"p"},"build.gradle")," looks now:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-groovy"},'import com.github.spotbugs.SpotBugsTask\n\nplugins {\n    id "io.spring.dependency-management" version "1.0.9.RELEASE"\n    id \'java\'\n    id \'com.github.johnrengelman.shadow\' version \'5.2.0\'\n    id "com.moowork.node" version "1.3.1"\n}\n\napply from: \'ui.gradle\'\n\nrepositories {\n    mavenCentral()\n}\n\ndependencies {\n    implementation \'com.epam.reportportal:plugin-api:5.4.0\'\n    annotationProcessor \'com.epam.reportportal:plugin-api:5.4.0\'\n}\n\nartifacts {\n    archives shadowJar\n}\n\nsourceSets {\n    main {\n        resources\n                {\n                    exclude \'**\'\n                }\n    }\n}\n\njar {\n    from("src/main/resources") {\n        into("/resources")\n    }\n    from("ui/build") {\n        into("/resources")\n    }\n    manifest {\n        attributes(\n                "Class-Path": configurations.compile.collect { it.getName() }.join(\' \'),\n                "Plugin-Id": "${pluginId}",\n                "Plugin-Version": "${project.version}",\n                "Plugin-Provider": "Report Portal",\n                "Plugin-Class": "com.epam.reportportal.extension.example.ExamplePlugin",\n                "Plugin-Service": "api"\n        )\n    }\n}\n\nshadowJar {\n    from("src/main/resources") {\n        into("/resources")\n    }\n    from("ui/build") {\n        into("/resources")\n    }\n    configurations = [project.configurations.compile]\n    zip64 true\n    dependencies {\n    }\n}\n\ntask plugin(type: Jar) {\n    getArchiveBaseName().set("plugin-${pluginId}")\n    into(\'classes\') {\n        with jar\n    }\n    into(\'lib\') {\n        from configurations.compile\n    }\n    extension(\'zip\')\n}\n\ntask assemblePlugin(type: Copy) {\n    from plugin\n    into pluginsDir\n}\n\ntask assemblePlugins(type: Copy) {\n    dependsOn subprojects.assemblePlugin\n}\n\ncompileJava.dependsOn npm_run_build\n')),(0,a.kt)("p",null,"Now we can just execute ",(0,a.kt)("em",{parentName:"p"},"./gradlew build")," and get plugin binaries (as jar and as shadowJar) that can be loaded to the application."),(0,a.kt)("h3",{id:"event-listeners"},"Event listeners"),(0,a.kt)("p",null,"All plugin commands are executed through the core application end-point with mapping:"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"https://host:port/v1/integration/{projectName}/{integrationId}/{command}")),(0,a.kt)("p",null,"As we can see ",(0,a.kt)("inlineCode",{parentName:"p"},"integrationId")," is a mandatory parameter that specifies integration to be used in the command execution."),(0,a.kt)("p",null,"We can affect logic executed in core application from the plugin by handling predefined set of events. As for now we will use\nmandatory ",(0,a.kt)("inlineCode",{parentName:"p"},"PluginLoadedEventHandler")," as an example."),(0,a.kt)("p",null,"This handler creates the very first integration and uses ",(0,a.kt)("inlineCode",{parentName:"p"},"PluginInfoProvider")," to update plugin data in the database."),(0,a.kt)("p",null,"To add a new listener we should use ",(0,a.kt)("inlineCode",{parentName:"p"},"ApplicationContext")," after plugin was loaded - so we do it in the method marked by ",(0,a.kt)("inlineCode",{parentName:"p"},"@PostConstruct"),"."),(0,a.kt)("p",null,"Also, we should remove listeners when we unload plugin - so we implement ",(0,a.kt)("inlineCode",{parentName:"p"},"DisposableBean")," interface and provide this logic in the ",(0,a.kt)("inlineCode",{parentName:"p"},"preDestroy()")," method."),(0,a.kt)("p",null,"That's how our extension looks now:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},'\n@Extension\npublic class ExampleExtension implements ReportPortalExtensionPoint, DisposableBean {\n\n    public static final String BINARY_DATA_PROPERTIES_FILE_ID = "example-binary-data.properties";\n    private static final String PLUGIN_ID = "example";\n    private final String resourcesDir;\n\n    private final Supplier<Map<String, PluginCommand<?>>> pluginCommandMapping = new MemoizingSupplier<>(this::getCommands);\n    private final Supplier<ApplicationListener<PluginEvent>> pluginLoadedListenerSupplier;\n\n    @Autowired\n    private ApplicationContext applicationContext;\n\n    @Autowired\n    private IntegrationTypeRepository integrationTypeRepository;\n\n    @Autowired\n    private IntegrationRepository integrationRepository;\n\n    public ExampleExtension(Map<String, Object> initParams) {\n        resourcesDir = IntegrationTypeProperties.RESOURCES_DIRECTORY.getValue(initParams).map(String::valueOf).orElse("");\n\n        pluginLoadedListenerSupplier = new MemoizingSupplier<>(() -> new ExamplePluginEventListener(PLUGIN_ID,\n                new PluginEventHandlerFactory(integrationTypeRepository,\n                        integrationRepository,\n                        new PluginInfoProviderImpl(resourcesDir, BINARY_DATA_PROPERTIES_FILE_ID)\n                )\n        ));\n    }\n\n    @Override\n    public Map<String, ?> getPluginParams() {\n        Map<String, Object> params = new HashMap<>();\n        params.put(ALLOWED_COMMANDS, new ArrayList<>(pluginCommandMapping.get().keySet()));\n        return params;\n    }\n\n    @Override\n    public PluginCommand<?> getCommandToExecute(String commandName) {\n        return pluginCommandMapping.get().get(commandName);\n    }\n\n    @PostConstruct\n    public void createIntegration() throws IOException {\n        initListeners();\n    }\n\n    private void initListeners() {\n        ApplicationEventMulticaster applicationEventMulticaster = applicationContext.getBean(AbstractApplicationContext.APPLICATION_EVENT_MULTICASTER_BEAN_NAME,\n                ApplicationEventMulticaster.class\n        );\n        applicationEventMulticaster.addApplicationListener(pluginLoadedListenerSupplier.get());\n    }\n\n    @Override\n    public void destroy() {\n        removeListeners();\n    }\n\n    private void removeListeners() {\n        ApplicationEventMulticaster applicationEventMulticaster = applicationContext.getBean(AbstractApplicationContext.APPLICATION_EVENT_MULTICASTER_BEAN_NAME,\n                ApplicationEventMulticaster.class\n        );\n        applicationEventMulticaster.removeApplicationListener(pluginLoadedListenerSupplier.get());\n    }\n\n    private Map<String, PluginCommand<?>> getCommands() {\n        Map<String, PluginCommand<?>> pluginCommandMapping = new HashMap<>();\n        pluginCommandMapping.put("getFile", new GetFileCommand(resourcesDir, BINARY_DATA_PROPERTIES_FILE_ID));\n        pluginCommandMapping.put("testConnection", (integration, params) -> true);\n        return pluginCommandMapping;\n    }\n}\n')),(0,a.kt)("h2",{id:"lazy-initialization"},"Lazy initialization"),(0,a.kt)("p",null,"All plugin components that relies on ",(0,a.kt)("inlineCode",{parentName:"p"},"@Autowired")," dependencies should be loaded lazily using ",(0,a.kt)("inlineCode",{parentName:"p"},"MemoizingSupplier")," or another lazy-load mechanism.\nThis is the restriction of plugin installation flow: "),(0,a.kt)("h5",{id:"we-create-extension-object-using-constructor-and-only-then-we-autowire-dependencies-if-we-dont-use-lazy-initialization---all-objects-created-in-the-constructor-will-be-created-with-null-objects-that-were-marked-as-autowired"},"We create extension object using constructor and only then we autowire dependencies. If we don't use lazy initialization - all objects created in the constructor will be created with ",(0,a.kt)("inlineCode",{parentName:"h5"},"NULL")," objects that were marked as ",(0,a.kt)("inlineCode",{parentName:"h5"},"@Autowired")))}d.isMDXComponent=!0},11931:(e,n,t)=>{t.r(n),t.d(n,{default:()=>i});const i=t.p+"assets/images/InstallPlugin-a1133a05f643c6e301c206898d0afc16.png"}}]);