"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[211],{65688:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"quality-gates/IntegrationWithCICD/IntegrationWithGitLabCI","title":"Integration with GitLab CI","description":"In this tutorial we will walk you through the process of integrating ReportPortal with GitLab CI. It is not the case for GitLab, but there are some recipes.","source":"@site/docs/quality-gates/IntegrationWithCICD/IntegrationWithGitLabCI.md","sourceDirName":"quality-gates/IntegrationWithCICD","slug":"/quality-gates/IntegrationWithCICD/IntegrationWithGitLabCI","permalink":"/docs/quality-gates/IntegrationWithCICD/IntegrationWithGitLabCI","draft":false,"unlisted":false,"editUrl":"https://github.com/reportportal/docs/blob/develop/docs/quality-gates/IntegrationWithCICD/IntegrationWithGitLabCI.md","tags":[],"version":"current","frontMatter":{"sidebar_label":"Integration with GitLab CI"},"sidebar":"docs","previous":{"title":"Integration with GitHub Actions","permalink":"/docs/quality-gates/IntegrationWithCICD/IntegrationWithGitHubActions"},"next":{"title":"Integration with Jenkins","permalink":"/docs/quality-gates/IntegrationWithCICD/IntegrationWithJenkins"}}');var s=n(74848),a=n(28453);const r={sidebar_label:"Integration with GitLab CI"},o="Integration with GitLab CI",l={},c=[{value:"Prerequisites",id:"prerequisites",level:2},{value:"Using Gitlab CI pipeline file",id:"using-gitlab-ci-pipeline-file",level:2},{value:"Define pipeline structure and rules",id:"define-pipeline-structure-and-rules",level:2},{value:"Getting test secrets",id:"getting-test-secrets",level:2},{value:"Running tests",id:"running-tests",level:2},{value:"Kotlin tests",id:"kotlin-tests",level:3},{value:"Python tests",id:"python-tests",level:3},{value:"Setting up Quality Gates integration (optional)",id:"setting-up-quality-gates-integration-optional",level:2},{value:"Getting Launch UUID for Kotlin tests",id:"getting-launch-uuid-for-kotlin-tests",level:3},{value:"Getting Launch UUID for Python tests",id:"getting-launch-uuid-for-python-tests",level:3},{value:"Adding Quality Gates stage",id:"adding-quality-gates-stage",level:3},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"integration-with-gitlab-ci",children:"Integration with GitLab CI"})}),"\n",(0,s.jsx)(t.p,{children:"In this tutorial we will walk you through the process of integrating ReportPortal with GitLab CI. It is not the case for GitLab, but there are some recipes."}),"\n",(0,s.jsx)(t.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,s.jsxs)(t.p,{children:["To run your tests in any kind of CI, you first need a way to execute them in the\nconsole. E.G. for Java this might be calling a build tool like Gradle or Maven\nwith: ",(0,s.jsx)(t.code,{children:"./gradlew test"})," or ",(0,s.jsx)(t.code,{children:"./mvnw test"})," respectively. For Python it might be\n",(0,s.jsx)(t.code,{children:"pytest"})," command. Your tests should be already ",(0,s.jsx)(t.a,{href:"/log-data-in-reportportal/test-framework-integration/",children:"integrated with a ReportPortal agent"}),". You also need a working ReportPortal instance and access to your secret storage, E.G.\n",(0,s.jsx)(t.a,{href:"https://www.vaultproject.io/",children:"HashiCorp Vault"}),", to securely get your\ncredentials while the pipeline is running."]}),"\n",(0,s.jsx)(t.h2,{id:"using-gitlab-ci-pipeline-file",children:"Using Gitlab CI pipeline file"}),"\n",(0,s.jsxs)(t.p,{children:["We are going to use the ",(0,s.jsx)(t.code,{children:".gitlab-ci.yml"})," file to store and modify our CI pipeline,\nthis file should be hosted in the same Git repository which contains your\ntests. We believe this is the most reliable way to reproduce and spread\npipeline configuration for many users. More on ",(0,s.jsx)(t.code,{children:".gitlab-ci.yml"})," syntax you can\nfind in the official ",(0,s.jsx)(t.a,{href:"https://docs.gitlab.com/ee/ci/yaml/gitlab_ci_yaml.html",children:"GitLab documentation"}),"."]}),"\n",(0,s.jsx)(t.h2,{id:"define-pipeline-structure-and-rules",children:"Define pipeline structure and rules"}),"\n",(0,s.jsx)(t.p,{children:"Before running tests, we need to define the steps we want to pass in our pipeline.\nThis is the common thing for any language or framework you might use, so let\u2019s\ndo that."}),"\n",(0,s.jsx)(t.p,{children:"First, we need to securely get our test credentials from a secure storage.\nThese credentials should not be stored in any kind of logs, artifacts,\nattachments during pipeline execution to avoid security breaches. Second, we\nneed to run tests with those credentials which we got from the first step. And\nthird, enterprise users might also want to utilize our Quality Gates plugin to\nget more control over application-under-test quality, this will be described in\nthe last section of the current article. Additionally, we will disable on-push\npipeline runs and allows only manual triggering."}),"\n",(0,s.jsx)(t.p,{children:"So, let's start with a basic yaml file skeleton:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-yaml",children:"workflow:\n  rules:\n    - if: '$CI_PIPELINE_SOURCE == \"push\"'\n      when: never  # Prevent pipeline run for push event\n    - when: always # Run pipeline for all other cases\n\nstages:\n  - secrets\n  - test\n\nsecrets:\n  stage: secrets\n\ntest:\n  stage: test\n  needs: ['secrets']\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Notice we put the ",(0,s.jsx)(t.code,{children:"needs: ['secrets']"})," property to run the test job only after we set\nup secrets."]}),"\n",(0,s.jsx)(t.h2,{id:"getting-test-secrets",children:"Getting test secrets"}),"\n",(0,s.jsx)(t.p,{children:"The latest GitLab CI versions support native integration with HashiCorp Vault\nfor Premium users, we recommend you use it instead of our solution to avoid\nconfiguration troubles. But for free users or older versions of GitLab we can\nprovide our own recipe."}),"\n",(0,s.jsx)(t.p,{children:"As prerequisites configure your Vault server for use with GitLab as described\nin official documentation and enable CI/CD on your project:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"https://docs.gitlab.com/ee/ci/secrets/#configure-your-vault-server",children:"https://docs.gitlab.com/ee/ci/secrets/#configure-your-vault-server"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"https://docs.gitlab.com/ee/ci/enable_or_disable_ci.html#enable-cicd-in-a-project",children:"https://docs.gitlab.com/ee/ci/enable_or_disable_ci.html#enable-cicd-in-a-project"})}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["Next, we are going to need Vault CLI to connect to the Vault Server. While we\ncan definitely install it in the ",(0,s.jsx)(t.code,{children:"before_script"})," section, it's better to use\nthe ",(0,s.jsx)(t.code,{children:"vault:1.13.3"})," base image to just get it. Instead in the ",(0,s.jsx)(t.code,{children:"before_script"})," we will\ninstall just a ",(0,s.jsx)(t.code,{children:"curl"})," tool to be able to call GitLab API."]}),"\n",(0,s.jsx)(t.p,{children:"This is how the Secrets section will look like:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-yaml",children:"secrets:\n  stage: secrets\n  image: vault:1.13.3\n  before_script:\n    - apk add --no-cache curl\n"})}),"\n",(0,s.jsx)(t.p,{children:"The idea of this solution is to get necessary secrets with Vault CLI and set\nthem as project variables to use further in the pipeline. To configure Vault CLI\nfor using the necessary server we can use these environment variables:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"VAULT_ADDR \u2013 remote address of your Vault server."}),"\n",(0,s.jsx)(t.li,{children:"VAULT_NAMESPACE \u2013 your working namespace on the server (if not default)."}),"\n",(0,s.jsx)(t.li,{children:"VAULT_CACERT \u2013 path to your Certificate Authority certificate."}),"\n",(0,s.jsx)(t.li,{children:"VAULT_TOKEN \u2013 a token to access Vault."}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"So, our Secrets section in the pipeline file will look like that:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-yaml",children:'secrets:\n  stage: secrets\n  image: vault:1.13.3\n  before_script:\n    - apk add --no-cache curl\n  script:\n    - export VAULT_ADDR=https://vault.example.com:8200\n    - export VAULT_NAMESPACE=rp/test/\n    # Put your Certificate Authority certificate path here\n    - export VAULT_CACERT=cacert.pem\n    - export VAULT_TOKEN="$(vault write -field=token auth/jwt/login role=tests-develop jwt=$CI_JOB_JWT)"\n    # These fields we get from Vault to operate\n    - RP_ADMIN_PASSWORD=$(vault kv get -field=rp.admin.password secrets/demo/test)\n    - RP_DEMO_KEY=$(vault kv get -field=rp.demo.key secrets/demo/test)\n'})}),"\n",(0,s.jsxs)(t.p,{children:["Where ",(0,s.jsx)(t.code,{children:"tests-develop"})," in the ",(0,s.jsx)(t.code,{children:"VAULT_TOKEN"})," variable initialization is a role name\nyou should configure on the Vault server as a prerequisite (with\nthe ",(0,s.jsx)(t.code,{children:"vault policy write [role name]"})," command). ",(0,s.jsx)(t.code,{children:"CI_JOB_JWT"})," is an environment\nvariable available in GitLab CI runtime. ",(0,s.jsx)(t.code,{children:"RP_ADMIN_PASSWORD"})," and ",(0,s.jsx)(t.code,{children:"RP_DEMO_KEY"}),"\nare those secrets which we want to get from Vault, they are stored by\nthe ",(0,s.jsx)(t.code,{children:"secrets/demo/test"})," path on Vault and named ",(0,s.jsx)(t.code,{children:"rp.admin.password"})," and\n",(0,s.jsx)(t.code,{children:"rp.demo.key"})," respectively."]}),"\n",(0,s.jsx)(t.p,{children:"To set pipeline variables, we need a GitLab API token. Create it with the\nfollowing steps:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsx)(t.li,{children:"Go to the GitLab user's profile page."}),"\n",(0,s.jsx)(t.li,{children:"In the left menu select Access Tokens."}),"\n",(0,s.jsxs)(t.li,{children:["Enter Token name, E.G.: ",(0,s.jsx)(t.code,{children:"gitlab_cicd"}),"."]}),"\n",(0,s.jsx)(t.li,{children:"Select the Expiration date of the token."}),"\n",(0,s.jsx)(t.li,{children:"Check \u201capi\u201d in the Select scopes section."}),"\n",(0,s.jsx)(t.li,{children:"Click Create personal access token."}),"\n",(0,s.jsxs)(t.li,{children:["Copy and save your token from ",(0,s.jsx)(t.code,{children:"Your new personal access token"})," field."]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"Now let\u2019s create our pipeline variables. To do this, go to your GitLab project\npage and do the following things:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsx)(t.li,{children:"Select Settings > CI/CD."}),"\n",(0,s.jsx)(t.li,{children:"Click Expand on the Variables section."}),"\n",(0,s.jsx)(t.li,{children:"Click Add variable."}),"\n",(0,s.jsx)(t.li,{children:"Fill Key and Value fields."}),"\n",(0,s.jsx)(t.li,{children:"(Strongly recommended) check Protect variable and Mask variable checkboxes."}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"For our example we need 3 such variables:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"GITLAB_API_TOKEN \u2013 for storing the Access token we created, to use GitLab API."}),"\n",(0,s.jsx)(t.li,{children:"RP_ADMIN_PASSWORD \u2013 example secret."}),"\n",(0,s.jsx)(t.li,{children:"RP_DEMO_KEY \u2013 another example secret."}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"To finish up our secret setup, we need to update the corresponding section once\nagain:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-yaml",children:'secrets:\n  stage: secrets\n  image: vault:1.13.3\n  before_script:\n    - apk add --no-cache curl\n  variables:\n    GITLAB_INSTANCE: \'https://git.example.com\'\n  script:\n    - export VAULT_ADDR=https://vault.example.com:8200\n    - export VAULT_NAMESPACE=rp/test/\n    # Put your Certificate Authority certificate path here\n    - export VAULT_CACERT=cacert.pem\n    - export VAULT_TOKEN="$(vault write -field=token auth/jwt/login role=tests-develop jwt=$CI_JOB_JWT)"\n    # These fields we get from Vault to operate\n    - RP_ADMIN_PASSWORD=$(vault kv get -field=rp.admin.password secrets/demo/test)\n    - RP_DEMO_KEY=$(vault kv get -field=rp.demo.key secrets/demo/test)\n    - >\n      curl -f -s -X PUT --header "Private-Token: $GITLAB_API_TOKEN" --header "Content-Type: application/json"\n      --data \'{"value": "\'"$RP_ADMIN_PASSWORD"\'"}\'\n      "${GITLAB_INSTANCE}/api/v4/projects/$CI_PROJECT_ID/variables/RP_ADMIN_PASSWORD" > /dev/null 2>&1\n    - >\n      curl -f -s -X PUT --header "Private-Token: $GITLAB_API_TOKEN" --header "Content-Type: application/json"\n      --data \'{"value": "\'"$RP_DEMO_KEY"\'"}\'\n      "${GITLAB_INSTANCE}/api/v4/projects/$CI_PROJECT_ID/variables/RP_DEMO_KEY" > /dev/null 2>&1\n'})}),"\n",(0,s.jsxs)(t.p,{children:["In two new script commands we call GitLab API with the ",(0,s.jsx)(t.code,{children:"curl"})," command setting up\nvalues for our variables: RP_ADMIN_PASSWORD and RP_DEMO_KEY. We use\nGITLAB_API_TOKEN variable to access GitLab API and CI_PROJECT_ID default\nenvironment variable to refer to our current project. Notice that you need to\nreplace ",(0,s.jsx)(t.code,{children:"git.example.com"})," with your git domain. Also notice that with\n",(0,s.jsx)(t.code,{children:"> /dev/null 2>&1"})," command suffix we mute any output from stdout and stderr for\nthe sake of security, to avoid accidental reveal of our secrets in case of request\nlogging or request error logging."]}),"\n",(0,s.jsx)(t.h2,{id:"running-tests",children:"Running tests"}),"\n",(0,s.jsx)(t.p,{children:"Let's imagine we need to run our tests on two different languages: Python based\ntests running with pytest and Kotlin based tests running with Gradle. These are\ntwo rather different environments with very different approaches which should\ngive you an idea of how that works."}),"\n",(0,s.jsx)(t.h3,{id:"kotlin-tests",children:"Kotlin tests"}),"\n",(0,s.jsxs)(t.p,{children:["As for secrets we need to start with defining the base worker image we are going to\nuse. Unfortunately, there are no official Kotlin Docker images on Docker Hub, so\nwe need to install it ourselves, in the ",(0,s.jsx)(t.code,{children:"before_script"})," section. But Kotlin is a\nJVM based language, so we need Java to run it. Let's pick a common JDK image\nfor that, E.G.: ",(0,s.jsx)(t.code,{children:"eclipse-temurin:11-jdk-jammy"}),", since OpenJDK\u2019s images are\nrather outdated and haven\u2019t been updated for years. This is Ubuntu based image,\nso we can install additional software with ",(0,s.jsx)(t.code,{children:"apt-get"}),"."]}),"\n",(0,s.jsx)(t.p,{children:'Here is updated the "test" section of our pipeline Yaml with Kotlin installation:'}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-yaml",children:"test:\n  stage: test\n  needs: ['secrets']\n  image: eclipse-temurin:11-jdk-jammy\n  variables:\n    KOTLIN_VERSION: '1.4.32'\n  before_script:\n    - apt-get update\n    - apt-get install -y unzip\n    - curl -L https://github.com/JetBrains/kotlin/releases/download/v$KOTLIN_VERSION/kotlin-compiler-$KOTLIN_VERSION.zip -o /tmp/kotlin-compiler.zip\n    - unzip /tmp/kotlin-compiler.zip -d /opt\n    - export PATH=$PATH:/opt/kotlinc/bin\n"})}),"\n",(0,s.jsxs)(t.p,{children:["As you can see, we install ",(0,s.jsx)(t.code,{children:"unzip"}),", then download the necessary Kotlin version with\ncurl, unzip it to ",(0,s.jsx)(t.code,{children:"/opt"})," and update the ",(0,s.jsx)(t.code,{children:"PATH"})," variable to make the Kotlin compiler\navailable from any folder in command line. Kotlin version was moved to a\nvariable to ease further pipeline updates."]}),"\n",(0,s.jsx)(t.p,{children:"Now, let's run our tests:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-yaml",children:"test:\n  stage: test\n  needs: ['secrets']\n  image: eclipse-temurin:11-jdk-jammy\n  variables:\n    KOTLIN_VERSION: '1.4.32'\n  before_script:\n    - apt-get update\n    - apt-get install -y unzip\n    - curl -L https://github.com/JetBrains/kotlin/releases/download/v$KOTLIN_VERSION/kotlin-compiler-$KOTLIN_VERSION.zip -o /tmp/kotlin-compiler.zip\n    - unzip /tmp/kotlin-compiler.zip -d /opt\n    - export PATH=$PATH:/opt/kotlinc/bin\n  script:\n    # Cast execution flag on gradle wrapper script file, just in case\n    - chmod +x ./gradlew\n    - ./gradlew :service-api:demoSmoke -Prp.api.key=$RP_DEMO_KEY -Prp.admin.password=$RP_ADMIN_PASSWORD\n"})}),"\n",(0,s.jsx)(t.p,{children:"We run our tests with Gradle wrapper and cast execution flag on runner script\njust in case. We also bypass our secrets through command line parameters to our\nGradle to use later in tests. They won't be exposed, since this is not\na replacement, but a reference to a variable."}),"\n",(0,s.jsx)(t.h3,{id:"python-tests",children:"Python tests"}),"\n",(0,s.jsxs)(t.p,{children:["Python tests are rather easy to configure, compared to Kotlin. We start with\ndefining the base worker image and we are going to use ",(0,s.jsx)(t.code,{children:"python:3.10.12"}),". This is\nDebian-based image, so we can also install additional software with ",(0,s.jsx)(t.code,{children:"apt-get"}),"\nif necessary. In the ",(0,s.jsx)(t.code,{children:"before_script"})," section we can install our requirements for\nthe project and run tests in the main section with ",(0,s.jsx)(t.code,{children:"pytest"})," command."]}),"\n",(0,s.jsx)(t.p,{children:'Here is the updated "test" section of our pipeline Yaml:'}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-yaml",children:'test:\n  stage: test\n  needs: [\'secrets\']\n  image: python:3.10.12\n  before_script:\n    - python -m pip install --upgrade pip\n    - pip install -rrequirements-dev.txt\n  script:\n    - pytest -sv --reportportal -m "not command_skip" -n 2 -o "rp_api_key=$RP_DEMO_KEY" tests\n'})}),"\n",(0,s.jsxs)(t.p,{children:["As you can see, we pass ",(0,s.jsx)(t.code,{children:"RP_DEMO_KEY"})," through the command line, that\u2019s safe, since\nthis is not a replacement, but a reference to a variable. You will see just a\nvariable name in the logs."]}),"\n",(0,s.jsx)(t.h2,{id:"setting-up-quality-gates-integration-optional",children:"Setting up Quality Gates integration (optional)"}),"\n",(0,s.jsxs)(t.p,{children:["Enterprise users can utilize our Quality Gates plugin to get more\ncontrol over application-under-test quality. To enable and configure Quality Gates plugin on\nReportPortal, please, refer to ",(0,s.jsx)(t.a,{href:"/quality-gates",children:"corresponding documentation"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"ReportPortal the Quality Gates plugin doesn't have native integration with GitLab, so we\nneed to use a custom approach here. One way is polling ReportPortal Launch info API for\na specific value, which the Quality Gates plugin leaves after passing. For that we need Launch\nUUID, which is a unique Launch identifier."}),"\n",(0,s.jsx)(t.h3,{id:"getting-launch-uuid-for-kotlin-tests",children:"Getting Launch UUID for Kotlin tests"}),"\n",(0,s.jsxs)(t.p,{children:["Every Java Agent has specific properties which control Launch UUID printing,\nsince July 2023. To ensure that check if your Agent has\nthe ",(0,s.jsx)(t.code,{children:"com.epam.reportportal:client-java"})," library dependency of version 5.1.23 or\nlate. It\u2019s generally safe to add exclusion and put a newer version of the library\nto get new features. So these properties are: ",(0,s.jsx)(t.code,{children:"rp.launch.uuid.print"})," and\n",(0,s.jsx)(t.code,{children:"rp.launch.uuid.print.output"}),". You can put them into your\n",(0,s.jsx)(t.code,{children:"reportportal.properties"})," file. Enable Launch UUID printing with the property:\n",(0,s.jsx)(t.code,{children:"rp.launch.uuid.print = true"}),". It will output a line like this into the console:\n",(0,s.jsx)(t.code,{children:"ReportPortal Launch UUID: 61ce1c26-842a-4bde-9abe-a4696e31d626"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"Our tests use Gradle to build and run them, unlike other build systems Gradle\nusually hides test output streams and just prints truncated stack trace in case\nof test failures, so we need to tell it not to do that. This is possible if you\nput the following section somewhere into your Gradle test task:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"testLogging {\n  showStandardStreams = true\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Next, we need to save this UUID to an environment variable which we latter will\nuse in a separate stage in polling ReportPortal API. GitLab allows this with ",(0,s.jsx)(t.a,{href:"https://docs.gitlab.com/ee/ci/variables/#pass-an-environment-variable-to-another-job",children:"dotenv\nfiles"}),"."]}),"\n",(0,s.jsx)(t.p,{children:'Here is the updated "test" stage which does these things:'}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-yaml",children:"test:\n  stage: test\n  needs: ['secrets']\n  image: eclipse-temurin:11-jdk-jammy\n  variables:\n    KOTLIN_VERSION: '1.4.32'\n  before_script:\n    - apt-get update\n    - apt-get install -y unzip\n    - curl -L https://github.com/JetBrains/kotlin/releases/download/v$KOTLIN_VERSION/kotlin-compiler-$KOTLIN_VERSION.zip -o /tmp/kotlin-compiler.zip\n    - unzip /tmp/kotlin-compiler.zip -d /opt\n    - export PATH=$PATH:/opt/kotlinc/bin\n  script:\n    # Cast execution flag on gradle wrapper script file, just in case\n    - chmod +x ./gradlew\n    - ./gradlew --console=plain :service-api:demoSmoke -Prp.api.key=$RP_DEMO_KEY -Prp.admin.password=$RP_ADMIN_PASSWORD | tee ./console.log  || true\n    - >\n      sed -rn 's/ReportPortal Launch UUID: ([^\\\\r\\\\n]+)/LAUNCH_UUID=\\1/ w launch.env' ./console.log\n"})}),"\n",(0,s.jsx)(t.p,{children:"Some explanations here:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["We used the ",(0,s.jsx)(t.code,{children:"--console=plain"})," Gradle parameter to make output suitable for saving in a file."]}),"\n",(0,s.jsxs)(t.li,{children:["To preserve console output, we used the ",(0,s.jsx)(t.code,{children:"tee"})," command, which copies standard input to each specified file, and to standard output."]}),"\n",(0,s.jsxs)(t.li,{children:['We need to configure our "test" stage not to fail in case of unsuccessful tests, since we are going to decide about test status on the Quality Gates step. This is done by adding the ',(0,s.jsx)(t.code,{children:" || true"})," suffix to test run command."]}),"\n",(0,s.jsxs)(t.li,{children:["We used the ",(0,s.jsx)(t.code,{children:"sed"})," command to format and save our Launch UUID into ",(0,s.jsx)(t.code,{children:"launch.env"})," file."]}),"\n",(0,s.jsxs)(t.li,{children:["Thus, we got a preformatted ",(0,s.jsx)(t.code,{children:"launch.env"})," file and attached it as an artifact, which then will be used to populate environment variables by GitLab."]}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"getting-launch-uuid-for-python-tests",children:"Getting Launch UUID for Python tests"}),"\n",(0,s.jsxs)(t.p,{children:["ReportPortal pytest agent has specific properties which control Launch UUID printing,\nsince version 5.2.2: ",(0,s.jsx)(t.code,{children:"rp_launch_uuid_print"})," and ",(0,s.jsx)(t.code,{children:"rp_launch_uuid_print_output"}),".\nYou can put them into your ",(0,s.jsx)(t.code,{children:"pytest.ini"})," file. For this example, we just need\none of them: ",(0,s.jsx)(t.code,{children:"rp_launch_uuid_print = True"}),". It will output a line like this\ninto the console:\n",(0,s.jsx)(t.code,{children:"ReportPortal Launch UUID: 61ce1c26-842a-4bde-9abe-a4696e31d626"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["Next, we need to save this UUID to an environment variable which we later will\nuse in a separate stage in polling ReportPortal API. GitLab allows this with ",(0,s.jsx)(t.a,{href:"https://docs.gitlab.com/ee/ci/variables/#pass-an-environment-variable-to-another-job",children:"dotenv\nfiles"}),"."]}),"\n",(0,s.jsx)(t.p,{children:'Here is the updated "test" stage which does these things:'}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-yaml",children:"test:\n  stage: test\n  needs: ['secrets']\n  image: python:3.10.12\n  before_script:\n    - python -m pip install --upgrade pip\n    - pip install -rrequirements-dev.txt\n  script:\n    - pytest -sv --reportportal -m \"not command_skip\" -n 2 -o \"rp_api_key=$RP_DEMO_KEY\" tests | tee ./console.log || true\n    - >\n      sed -rn 's/ReportPortal Launch UUID: ([^\\\\r\\\\n]+)/LAUNCH_UUID=\\1/ w launch.env' ./console.log\n"})}),"\n",(0,s.jsx)(t.p,{children:"Some explanations here:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["To preserve console output, we used the ",(0,s.jsx)(t.code,{children:"tee"})," command, which copies standard input to each specified file, and to standard output."]}),"\n",(0,s.jsxs)(t.li,{children:['We need to configure our "test" stage not to fail in case of unsuccessful tests, since we are going to decide about test status on the Quality Gates step. This is done by adding the ',(0,s.jsx)(t.code,{children:" || true"})," suffix to test run command."]}),"\n",(0,s.jsxs)(t.li,{children:["We used the ",(0,s.jsx)(t.code,{children:"sed"})," command to format and save our Launch UUID into ",(0,s.jsx)(t.code,{children:"launch.env"})," file."]}),"\n",(0,s.jsxs)(t.li,{children:["Thus, we got a preformatted the ",(0,s.jsx)(t.code,{children:"launch.env"})," file and attached it as an artifact, which then will be used to populate environment variables by GitLab."]}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"adding-quality-gates-stage",children:"Adding Quality Gates stage"}),"\n",(0,s.jsx)(t.p,{children:"If you did your pipeline configuration in the same manner as in this article\nthis step will be the same for you, no matter which language do you use."}),"\n",(0,s.jsxs)(t.p,{children:["As the first step we need to add the ",(0,s.jsx)(t.code,{children:"quality-gate"})," stage to our pipeline:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-yaml",children:"stages:\n  - secrets\n  - test\n  - quality-gate\n\nquality-gate:\n  stage: quality-gate\n  needs: ['test']\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Notice that we put the ",(0,s.jsx)(t.code,{children:"needs: ['test']"})," property to run the Quality Gates job only after we pass\ntests."]}),"\n",(0,s.jsxs)(t.p,{children:["The second step will be a little bit tricky. Since we don't specify any image, we\ndon't really know which base image is used in our GitLab instance. This might\nbe an Ubuntu/Debian based image, or Alpine Linux, or anything else, depending\non which workers were chosen by your operations team. But we need to ensure we\nhave ",(0,s.jsx)(t.code,{children:"curl"})," and ",(0,s.jsx)(t.code,{children:"jq"})," tools to call ReportPortal API, so we need to install them in\nthe ",(0,s.jsx)(t.code,{children:"before_script"})," section. Let's make it universal for Debian and Alpine like\nthat:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-yaml",children:"quality-gate:\n  stage: quality-gate\n  needs: ['test']\n  before_script:\n    - apt-get update || apk update\n    - apt-get install -y curl jq || apk add --no-cache curl jq\n"})}),"\n",(0,s.jsxs)(t.p,{children:['As you can see, we used logical "or" sign ',(0,s.jsx)(t.code,{children:"||"})," to call ",(0,s.jsx)(t.code,{children:"apk"}),", which is Alpine\npackaging tool, in case ",(0,s.jsx)(t.code,{children:"apt-get"})," does not exist and therefore returns failure\nresult."]}),"\n",(0,s.jsx)(t.p,{children:"Now, it's time to finish our script, this will be a rather complex one:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-yaml",children:'quality-gate:\n  stage: quality-gate\n  needs: [\'test\']\n  before_script:\n    - apt-get update || apk update\n    - apt-get install -y curl jq || apk add --no-cache curl jq\n  variables:\n    RP_INSTANCE: \'https://demo.reportportal.io\'\n    SCRIPT_TIMEOUT_SECONDS: 60\n    REQUEST_TIMEOUT_SECONDS: 60\n  script: |\n    echo "Quality gate"\n    echo "LAUNCH_UUID: $LAUNCH_UUID"\n    QUALITY_GATE_STATUS=""\n    START_TIME=$(date +%s)\n    while ( [ -z "$QUALITY_GATE_STATUS" ] || [ "$QUALITY_GATE_STATUS" == "UNDEFINED" ] ) && [ $(( $(date +%s) - START_TIME )) -lt $TIMEOUT_SECONDS ]; do\n      echo "Waiting for quality gate status..."\n      sleep 10\n      QUALITY_GATE_JSON=$(curl -s -H "Authorization: Bearer $RP_DEMO_KEY" --max-time "$REQUEST_TIMEOUT_SECONDS" "${RP_INSTANCE}/api/v1/report_portal_demo/launch/${LAUNCH_UUID}")\n      QUALITY_GATE_STATUS=$(echo "$QUALITY_GATE_JSON" | jq -r \'.metadata.qualityGate.status // empty\')\n    done\n    if [ "$QUALITY_GATE_STATUS" != "PASSED" ]; then\n      echo "Quality gate status: $QUALITY_GATE_STATUS"\n      echo "Failing the pipeline."\n      exit 1\n    else\n      echo "Quality gate status: $QUALITY_GATE_STATUS"\n      echo "Pipeline passed."\n    fi\n'})}),"\n",(0,s.jsxs)(t.p,{children:["Notice, that we have moved the ReportPortal base URL configuration, polling timeout and request timeout\nto the variables section to ease their update. In script we are polling our ReportPortal\ninstance for Launch info with ",(0,s.jsx)(t.code,{children:"curl"})," and Launch UUID, which we got in the previous\nstep. After that with ",(0,s.jsx)(t.code,{children:"jq"})," we are trying to read a specific field in response\nJSON or return empty value if Quality Gate is not passed yet, or request is failed. In\ncase of an empty response, we retry our call to ReportPortal. Finally, we compare ",(0,s.jsx)(t.code,{children:"jq"}),'\noutput with "PASSED" literal and if it\u2019s equal we quit gracefully, or we fail\nthe step in any other case.']}),"\n",(0,s.jsx)(t.p,{children:"And we are finally done!"}),"\n",(0,s.jsx)(t.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsx)(t.p,{children:"ReportPortal does not have native integration with GitLab, but that\u2019s not something that\nmight stop you. In this article we set up GitLab integration with ReportPortal using\nshell scripts and console commands. We also implemented HashiCorp Vault\nintegration to store our test secrets securely. To provide more outlook we\ndescribed how to run tests in Kotlin and Python."}),"\n",(0,s.jsx)(t.p,{children:"And here are the corresponding pipeline files, which we implemented:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"https://github.com/reportportal/examples-java/blob/master/.gitlab-ci.yml",children:"Kotlin"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"https://github.com/reportportal/examples-python/blob/master/.gitlab-ci.yml",children:"Python"})}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>o});var i=n(96540);const s={},a=i.createContext(s);function r(e){const t=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(a.Provider,{value:t},e.children)}}}]);