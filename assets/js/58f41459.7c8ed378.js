"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[58658],{51438:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>a,toc:()=>h});var i=s(85893),n=s(11151);const o={sidebar_position:4,sidebar_label:"ML Suggestions"},r="ML Suggestions",a={id:"analysis/MLSuggestions",title:"ML Suggestions",description:"ML suggestions functionality is based on previously analyzed results (either manually or via Auto-analysis feature) using Machine Learning. The functionality is provided by the Analyzer service in combination with OpenSearch.",source:"@site/docs/analysis/MLSuggestions.md",sourceDirName:"analysis",slug:"/analysis/MLSuggestions",permalink:"/docs/analysis/MLSuggestions",draft:!1,unlisted:!1,editUrl:"https://github.com/reportportal/docs/blob/develop/docs/analysis/MLSuggestions.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4,sidebar_label:"ML Suggestions"},sidebar:"docs",previous:{title:'Search for the similar "To investigate" items',permalink:"/docs/analysis/SearchForTheSimilarToInvestigateItems"},next:{title:"How models are retrained",permalink:"/docs/analysis/HowModelsAreRetrained"}},l={},h=[{value:"How the ML suggestions functionality is working",id:"how-the-ml-suggestions-functionality-is-working",level:2}];function c(e){const t={admonition:"admonition",em:"em",h1:"h1",h2:"h2",li:"li",p:"p",ul:"ul",...(0,n.a)(),...e.components},{MediaViewer:s}=t;return s||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("MediaViewer",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h1,{id:"ml-suggestions",children:"ML Suggestions"}),"\n",(0,i.jsx)(t.p,{children:"ML suggestions functionality is based on previously analyzed results (either manually or via Auto-analysis feature) using Machine Learning. The functionality is provided by the Analyzer service in combination with OpenSearch."}),"\n",(0,i.jsx)(t.p,{children:"This analysis hints what are the most similar analyzed items to the current test item. You can interact with this functionality in several ways:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Choose one of the suggested items if you see that the reason for the current test item is similar to the suggested one. When you choose the item and apply changes to the current item, the following test item characteristics will be copied from the chosen test item:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"a defect type;"}),"\n",(0,i.jsxs)(t.li,{children:["a link to BTS ",(0,i.jsx)(t.em,{children:"(in case if it exists)"}),";"]}),"\n",(0,i.jsxs)(t.li,{children:["comment ",(0,i.jsx)(t.em,{children:"(in case if it exists)"}),";"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"If you see no suitable suggested test item for the current test item, just do not select any of them."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"how-the-ml-suggestions-functionality-is-working",children:"How the ML suggestions functionality is working"}),"\n",(0,i.jsx)(t.p,{children:"ML Suggestions searches for similar previously analyzed items to the current test item, so it requires an analytical base saved in OpenSearch. ML suggestions takes into account all user-investigated, auto-analyzed items or items chosen from ML suggestions. While the analytical base is growing ML suggestions functionality will have more examples to search by and suggest you the best options."}),"\n",(0,i.jsx)(t.p,{children:'ML suggestions analysis is run everytime you enter "Make decision" editor. ML suggestions are run for all test items no matter what defect type they have now. This functionality is processing only test items with logs (log level >= 40000).'}),"\n",(0,i.jsx)(t.p,{children:"The request for the suggestions part looks like this:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"testItemId;"}),"\n",(0,i.jsx)(t.li,{children:"uniqueId;"}),"\n",(0,i.jsx)(t.li,{children:"testCaseHash;"}),"\n",(0,i.jsx)(t.li,{children:"launchId;"}),"\n",(0,i.jsx)(t.li,{children:"launchName;"}),"\n",(0,i.jsx)(t.li,{children:"project;"}),"\n",(0,i.jsx)(t.li,{children:"analyzerConfig;"}),"\n",(0,i.jsx)(t.li,{children:"logs = List of log objects (logId, logLevel, message)"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"The Analyzer preprocesses log messages from the request for analysis: extracts error message, stacktrace, numbers, exceptions, urls, paths, parameters and other parts from text to search for the most similar items by these parts in the analytical base. We make several requests to the OpenSearch to find similar test items by all the error logs."}),"\n",(0,i.jsx)(t.admonition,{type:"note",children:(0,i.jsx)(t.p,{children:"When a test item has several error logs, we will use the log with the highest score as a representative of this test item."})}),"\n",(0,i.jsx)(t.p,{children:"The OpenSearch returns to the service Analyzer 10 logs with the highest score for each query and all these candidates will be processed further by the ML model. The ML model is an XGBoost model which features (about 40 features) represent different statistics about the test item, log message texts, launch info and etc, for example:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"the percent of selected test items with the following defect type"}),"\n",(0,i.jsx)(t.li,{children:"max/min/mean scores for the following defect type"}),"\n",(0,i.jsx)(t.li,{children:"cosine similarity between vectors, representing error message/stacktrace/the whole message/urls/paths and other text fields"}),"\n",(0,i.jsx)(t.li,{children:"whether it has the same unique id, from the same launch"}),"\n",(0,i.jsx)(t.li,{children:"the probability for being of a specific defect type given by the Random Forest Classifier trained on Tf-Idf vectors"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"The model gives a probability for each candidate, we filter out test items with the probability less or equal 40%. We sort the test items by this probability, after that we deduplicate test items inside this ranked list. If two test items are similar with >= 98% by their messages, then we will leave the test item with the highest probability. After deduplication we take maximimum 5 items with the highest score to show in the ML Suggestions section."}),"\n",(0,i.jsx)(t.p,{children:"ML suggestions section contains at maximum 5 suggested items, they are shown together with the scores given by the model and we divide them into 3 groups:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:'the group "SAME", test items with the score = 100%'}),"\n",(0,i.jsx)(t.li,{children:'the group "HIGH", test items with the score in the range [70% - 99.9%]'}),"\n",(0,i.jsx)(t.li,{children:'the group "LOW", test items with the score in the range [40% - 69.9%]'}),"\n"]}),"\n",(0,i.jsx)(s,{src:"https://youtu.be/Ooggk-k5fTQ",alt:"ML Suggestions",type:"video"})]})}function d(e={}){const{wrapper:t}={...(0,n.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},11151:(e,t,s)=>{s.d(t,{Z:()=>a,a:()=>r});var i=s(67294);const n={},o=i.createContext(n);function r(e){const t=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:r(e.components),i.createElement(o.Provider,{value:t},e.children)}}}]);