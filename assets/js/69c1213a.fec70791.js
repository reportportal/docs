"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[5203],{80411:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>t,toc:()=>h});const t=JSON.parse('{"id":"analysis/AutoAnalysisOfLaunches","title":"Auto-Analysis of launches","description":"The analysis feature of the ReportPortal makes it possible for the application to check and pass part of the routine duties by itself.","source":"@site/docs/analysis/AutoAnalysisOfLaunches.mdx","sourceDirName":"analysis","slug":"/analysis/AutoAnalysisOfLaunches","permalink":"/docs/analysis/AutoAnalysisOfLaunches","draft":false,"unlisted":false,"editUrl":"https://github.com/reportportal/docs/blob/develop/docs/analysis/AutoAnalysisOfLaunches.mdx","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1,"sidebar_label":"Auto-Analysis of launches"},"sidebar":"docs","previous":{"title":"Analysis","permalink":"/docs/analysis/"},"next":{"title":"Immediate Auto-Analysis","permalink":"/docs/analysis/ImmediateAutoAnalysis"}}');var a=s(74848),i=s(28453);const o={sidebar_position:1,sidebar_label:"Auto-Analysis of launches"},r="Auto-Analysis of launches",l={},h=[{value:"ReportPortal Analyzer. How the Auto-Analysis is working",id:"reportportal-analyzer-how-the-auto-analysis-is-working",level:2},{value:"Create an analytical base in the OpenSearch",id:"create-an-analytical-base-in-the-opensearch",level:3},{value:"Auto-Analysis process",id:"auto-analysis-process",level:3},{value:"How OpenSearch returns candidates for Analysis",id:"how-opensearch-returns-candidates-for-analysis",level:3},{value:"How Auto-analysis makes decisions for candidates, returned by OpenSearch",id:"how-auto-analysis-makes-decisions-for-candidates-returned-by-opensearch",level:3},{value:"Auto-analysis Settings",id:"auto-analysis-settings",level:2},{value:"Switch ON/OFF automatic analysis",id:"switch-onoff-automatic-analysis",level:3},{value:"Base for analysis",id:"base-for-analysis",level:3},{value:"Defect assignment based on the longest retry",id:"defect-assignment-based-on-the-longest-retry",level:3},{value:"Remove/Generate OpenSearch index",id:"removegenerate-opensearch-index",level:3},{value:"Manual analysis",id:"manual-analysis",level:3},{value:"Label AA",id:"label-aa",level:2},{value:"Ignore in Auto-Analysis",id:"ignore-in-auto-analysis",level:2}];function c(e){const n={a:"a",admonition:"admonition",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components},{MediaViewer:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("MediaViewer",!0),(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"auto-analysis-of-launches",children:"Auto-Analysis of launches"})}),"\n",(0,a.jsx)(n.p,{children:"The analysis feature of the ReportPortal makes it possible for the application to check and pass part of the routine duties by itself."}),"\n",(0,a.jsx)(n.p,{children:"Auto-analysis performs automated defect triaging and defines the reason for the test item failure and sets:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"a defect type;"}),"\n",(0,a.jsxs)(n.li,{children:["a link to BTS ",(0,a.jsx)(n.em,{children:"(in case if it exists)"}),";"]}),"\n",(0,a.jsxs)(n.li,{children:["comment ",(0,a.jsx)(n.em,{children:"(in case if it exists)"}),";"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"The process of Auto-Analysis is based on previous user-investigated users' results using Machine Learning."}),"\n",(0,a.jsx)(n.p,{children:"An auto-analyzer is presented by a combination of several services: OpenSearch and Analyzer service (two instances Analyzer and Analyzer train)."}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"OpenSearch contains an analytical base and stores training data for retraining of models."}),"\n",(0,a.jsx)(n.li,{children:"Analyzer instance performs all operations, connected with the basic functionality (indexing/removing logs, searching logs, auto-analysis,  ML suggestions)."}),"\n",(0,a.jsx)(n.li,{children:"Analyzer train instance is responsible for training models for Auto-analysis and ML suggestions functionality."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.em,{children:"You have the option to disable the Analyzer by removing the Analyzer and Analyzer train services from the installation."})}),"\n",(0,a.jsx)(n.p,{children:"There are several ways to use an analyzer in our test automation reporting dashboard:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["Use  the ReportPortal Analyzer: ",(0,a.jsx)(n.strong,{children:"manual"})," (analysis is switched on only for chosen launch manually) or ",(0,a.jsx)(n.strong,{children:"auto"})," (analysis is switched on after the launch finishing automatically);"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Implement and configure your custom Analyzer and do not deploy ReportPortal service Analyzer;"}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Do not use any Analyzers at all and do an analytical routine by yourself;"}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.admonition,{type:"important",children:(0,a.jsx)(n.p,{children:"The Auto Analyzer service is a part of the ReportPortal bundle."})}),"\n",(0,a.jsx)(n.h2,{id:"reportportal-analyzer-how-the-auto-analysis-is-working",children:"ReportPortal Analyzer. How the Auto-Analysis is working"}),"\n",(0,a.jsx)(n.p,{children:"ReportPortal's Auto Analyzer allows users to reduce the time spent on test execution investigation by analyzing test failures in automatic mode. The default analysis component is running along with OpenSearch which is used for test logs indexing.\nFor effective using Auto\u2013Analysis you should come through several stages."}),"\n",(0,a.jsx)(n.h3,{id:"create-an-analytical-base-in-the-opensearch",children:"Create an analytical base in the OpenSearch"}),"\n",(0,a.jsx)(n.p,{children:"First of all, you need to create an analytical base. For that, you should start to analyze test results manually."}),"\n",(0,a.jsx)(n.p,{children:"All test items with a defect type which have been analyzed manually or automatically by ReportPortal are sent to the OpenSearch."}),"\n",(0,a.jsx)(n.p,{children:"The following info is sent:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"An item ID;"}),"\n",(0,a.jsx)(n.li,{children:"Logs (each log should be with level Error and higher (log level >= 40 000));"}),"\n",(0,a.jsx)(n.li,{children:"Issue type;"}),"\n",(0,a.jsx)(n.li,{children:"Flag: \u201cAnalyzed by\u201d (where shows by whom the test item has been analyzed by a user or by ReportPortal);"}),"\n",(0,a.jsx)(n.li,{children:"A launch name;"}),"\n",(0,a.jsx)(n.li,{children:"Launch ID;"}),"\n",(0,a.jsx)(n.li,{children:"Test case ID;"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:'For the better analysis, we merge small logs (which consist of 1-2 log lines and words number less or equal 100) together. We store this merged log message as a separate document if there are no other big logs (consisting of more than 2 log lines or having a stacktrace) in the test item. We store this merged log message in a separate field "merged_small_logs" for all the big logs if there are ones.'}),"\n",(0,a.jsx)(n.p,{children:"The Analyzer preprocesses log messages from the request for test failure analysis: extracts error message, stacktrace, numbers, exceptions, urls, paths, parameters and other parts from text to search for the most similar items by these parts in the analytical base. These parts are saved in a separate fields for each log entry."}),"\n",(0,a.jsx)(n.p,{children:"Each log entry along with its defect type is saved to OpenSearch in the form of a separate document. All documents created compose an Index. The more test results index has, the more accurate results will be generated by the end of the analysis process."}),"\n",(0,a.jsxs)(n.admonition,{type:"tip",children:[(0,a.jsx)(n.p,{children:"If you do not sure how many documents(logs) are contained in the Index at that moment, you can check it.\nFor that, perform the following actions:"}),(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Uncommented Service OpenSearch ports in a docker-compose file or add them: 9200:9200;"}),"\n",(0,a.jsx)(n.li,{children:"Restart-Service OpenSearch with new docker-compose;"}),"\n",(0,a.jsxs)(n.li,{children:["Send a request to OpenSearch:","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["how many documents in the Index: GET ",(0,a.jsx)(n.a,{href:"http://localhost:9200/_cat/indices?v",children:"http://localhost:9200/_cat/indices?v"})]}),"\n",(0,a.jsxs)(n.li,{children:["Detailed information:  POST ",(0,a.jsx)(n.a,{href:"http://localhost:9200/%7Bproject_name%7D/_search",children:"http://localhost:9200/{project_name}/_search"})]}),"\n"]}),"\n"]}),"\n"]})]}),"\n",(0,a.jsx)(n.p,{children:"Test items of a launch in Debug mode are not sent to the service Analyzer. If the test item is deleted or moved to the Debug mode, it is removed from the Index."}),"\n",(0,a.jsx)(n.h3,{id:"auto-analysis-process",children:"Auto-Analysis process"}),"\n",(0,a.jsx)(n.p,{children:"After your Index has been completed. You can start to use the auto-analysis feature."}),"\n",(0,a.jsx)(n.p,{children:"Analysis can be launched automatically (via Project Settings) or manually (via the menu on All launches view). After the process is started, all items with defect type \u201cTo investigate\u201d with logs (log level >= 40 000) from the analyzed launch are picked and sent to the Analyzer Service and the service OpenSearch for investigations."}),"\n",(0,a.jsx)(n.h3,{id:"how-opensearch-returns-candidates-for-analysis",children:"How OpenSearch returns candidates for Analysis"}),"\n",(0,a.jsx)(n.p,{children:"Here is a simplified procedure of the Auto-analysis candidates searching via OpenSearch."}),"\n",(0,a.jsx)(n.p,{children:'When a "To investigate" test item appears we search for the most similar test items in the analytical base. We create a query which searches by several fields, message similarity is a compulsory condition, other conditions boost the better results and they will have a higher score (boost conditions are similarity by launch name, error message, found exceptions, numbers in the logs and etc.).'}),"\n",(0,a.jsx)(n.p,{children:"Then OpenSearch receives a log message and divides it into the terms (words) with a tokenizer and calculates the importance of each term (word). For that OpenSearch computes TF-IDF for each term (word) in the analyzed log. If the level of term importance is low, the OpenSearch ignores it."}),"\n",(0,a.jsxs)(n.admonition,{type:"note",children:[(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.em,{children:"Term frequency (TF)"})," \u2013 how many time term (word) is used in an analyzed log;"]}),(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.em,{children:"Document frequency (DF)"})," \u2013 in how many documents this term (word) is used in Index;"]}),(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.em,{children:"TF-IDF (TF \u2014 term frequency, IDF \u2014 inverse document frequency)"})," \u2014 a statistical measure used to assess the importance of a term (word) in the context of a log that is part of an Index. The weight of a term (word)   is proportional to the amount of use of this term (word)   in the analyzed log and inversely proportional to the frequency of term (word)   usage in Index."]})]}),"\n",(0,a.jsx)(n.p,{children:"The term (word) with the highest level of importance is the term (word) that is used very frequently in analyzed log and moderately in the Index."}),"\n",(0,a.jsx)(n.p,{children:"After all important terms are defined, OpenSearch calculates the level of equality between an analyzed log and each log in the Index.  For each log from the Index is calculated a score."}),"\n",(0,a.jsxs)(n.admonition,{type:"note",children:[(0,a.jsx)(n.p,{children:"How calculated a score:"}),(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"score(q,d)"})," ="]}),(0,a.jsx)(n.p,{children:"coord(q,d) -\nSUM (\ntf(t in d),\nidf(t)\xb2,\nt.getBoost(),\n) (t in q)\nWhere:"}),(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"score(q,d) is the relevance score of log \u201cd\u201d for query \u201cq\u201d."}),"\n",(0,a.jsx)(n.li,{children:"coord(q,d) is the coordination factor: the percent of words equality between analyzed log and particular log from the OpenSearch."}),"\n",(0,a.jsx)(n.li,{children:"The sum of the weights for each word \u201ct\u201d in the query \u201cq\u201d for log \u201cd\u201d."}),"\n",(0,a.jsx)(n.li,{children:"tf(t in d) is a frequency of the word in the analyzed log."}),"\n",(0,a.jsx)(n.li,{children:"idf(t) is the inverse frequency of the word in all saved logs in the Index."}),"\n",(0,a.jsxs)(n.li,{children:["t.getBoost() is the boost that has been applied to the query. The higher priority for logs with:","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"The same Launch name;"}),"\n",(0,a.jsx)(n.li,{children:"The same UID;"}),"\n",(0,a.jsx)(n.li,{children:"Manual analysis;"}),"\n",(0,a.jsx)(n.li,{children:"Error message;"}),"\n",(0,a.jsx)(n.li,{children:"The same numbers in the log;"}),"\n",(0,a.jsx)(n.li,{children:"and etc."}),"\n"]}),"\n"]}),"\n"]})]}),"\n",(0,a.jsx)(n.p,{children:'The results are sorted by the score, in case the scores are the same, they are sorted by "start_time" field, which helps to boost the test items with closer to today dates. So the latest defect types will be higher in the returned by OpenSearch results.'}),"\n",(0,a.jsx)(n.p,{children:"The OpenSearch returns to the service Analyzer 10 logs with the highest score for each log. Analyzer regroups all the results by a defect type and chooses the best representative for each defect type group, based on their scores."}),"\n",(0,a.jsx)(n.admonition,{type:"note",children:(0,a.jsx)(n.p,{children:"In the case the test item has several logs, the best representative for a defect type group will become the log with the highest score among all logs."})}),"\n",(0,a.jsx)(n.h3,{id:"how-auto-analysis-makes-decisions-for-candidates-returned-by-opensearch",children:"How Auto-analysis makes decisions for candidates, returned by OpenSearch"}),"\n",(0,a.jsx)(n.p,{children:"The OpenSearch returns to the service Analyzer 10 logs with the highest score for each query and all these candidates will be processed further by the ML model. Analyzer regroups all the results by a defect type and chooses the best representative for each defect type group, based on their scores."}),"\n",(0,a.jsx)(n.p,{children:"The ML model is an XGBoost model which features (about 30 features) represent different statistics about the test item, log message texts, launch info and etc, for example:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"the percent of selected test items with the following defect type"}),"\n",(0,a.jsx)(n.li,{children:"max/min/mean scores for the following defect type"}),"\n",(0,a.jsx)(n.li,{children:"cosine similarity between vectors, representing error message/stacktrace/the whole message/urls/paths and other text fields"}),"\n",(0,a.jsx)(n.li,{children:"the probability for being of a specific defect type given by the Random Forest Classifier trained on Tf-Idf vectors"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"The model gives a probability for each defect type group, and we choose the defect type group with the highest probability and the probability should be >= 50%."}),"\n",(0,a.jsx)(n.p,{children:"A defect comment and a link to BTS of the best representative from this group come to the analyzed item."}),"\n",(0,a.jsx)(n.p,{children:'The Auto-analysis model is retrained for the project and this information can be found in the section "How models are retrained" below.'}),"\n",(0,a.jsx)(n.p,{children:"So this is how Auto-Analysis works and defines the most relevant defect type on the base of the previous investigations. We give an ability to our users to configure auto-analysis manually."}),"\n",(0,a.jsx)(n.h2,{id:"auto-analysis-settings",children:"Auto-analysis Settings"}),"\n",(0,a.jsx)(n.p,{children:"All settings and configurations of Analyzer and OpenSearch are situated on a separate tab on Project settings."}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Login into ReportPortal instance as Administrator or project member with PROJECT MANAGER role on the project;"}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Come on Project Settings, choose Auto-Analysis section;"}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t,{src:"https://youtu.be/0AK2OHD79Ps",alt:"Auto-analysis settings for AI-based defects triage",type:"video"}),"\n",(0,a.jsx)(n.p,{children:"In this section user can perform the following actions:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Switch ON/OFF auto-analysis;"}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Choose a base for analysis (All launches/ Launches with the same name);"}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Configure OpenSearch settings;"}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Remove/Generate OpenSearch index."}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"switch-onoff-automatic-analysis",children:"Switch ON/OFF automatic analysis"}),"\n",(0,a.jsx)(n.p,{children:'To activate the "Auto-Analysis" functionality in a project, perform the following steps:'}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Login ReportPortal instance as Administrator or project member with PROJECT MANAGER role on the project."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:'Select ON  in the "Auto-Analysis" selector on the Project settings / Auto-analysis section.'}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:'Click the "Submit" button. Now "Auto-Analysis" will start as soon as any launch finishes.'}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"base-for-analysis",children:"Base for analysis"}),"\n",(0,a.jsx)(n.p,{children:"You can choose which results from previous runs should be considered in Auto-Analysis for defining the failure reason."}),"\n",(0,a.jsx)(n.p,{children:"There are five options:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"All previous launches"}),"\n",(0,a.jsx)(n.li,{children:"Current and all previous launches with the same name"}),"\n",(0,a.jsx)(n.li,{children:"All previous launches with the same name"}),"\n",(0,a.jsx)(n.li,{children:"Only previous launch with the same name"}),"\n",(0,a.jsx)(n.li,{children:"Only current launch"}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["If you choose ",(0,a.jsx)(n.strong,{children:"\u201cAll previous launches\u201d"})," option, test results in the launch will have analyzed on the base of all runs before the current launch regardless of the launch name."]}),"\n",(0,a.jsxs)(n.p,{children:["If you choose ",(0,a.jsx)(n.strong,{children:"\u201cCurrent and all previous launches with the same name\u201d"})," option, test results in the launch will have analyzed on the base of current and all previous launches that have the same Launch name."]}),"\n",(0,a.jsxs)(n.p,{children:["If you choose ",(0,a.jsx)(n.strong,{children:"\u201cAll previous launches with the same name\u201d"})," option, test results in the launch will have analyzed on the base of all launches before current launch that have the same Launch name."]}),"\n",(0,a.jsxs)(n.p,{children:["If you choose ",(0,a.jsx)(n.strong,{children:"\u201cOnly previous launch with the same name\u201d"})," option, test results in the launch will have analyzed on the base of last run before current launch with the same name."]}),"\n",(0,a.jsxs)(n.p,{children:["If you choose ",(0,a.jsx)(n.strong,{children:"\u201cOnly current launch\u201d"})," option, test results in the launch will have analyzed on the base of current launch."]}),"\n",(0,a.jsx)(n.p,{children:"Imagine that the launches in the image below are part of your ReportPortal project, and currently, Smoke Launch 3 is being analyzed."}),"\n",(0,a.jsx)(t,{src:s(89392),alt:"Launches on the project"}),"\n",(0,a.jsxs)(n.p,{children:["So, launches that will have analyzed if you choose ",(0,a.jsx)(n.strong,{children:"\u201cAll previous launches\u201d"})," option: Smoke Launch 1, Smoke Launch 2, Regression Launch 1, Regression Launch 2, Regression Launch 3."]}),"\n",(0,a.jsxs)(n.p,{children:["Launches that will have analyzed if you choose ",(0,a.jsx)(n.strong,{children:"\u201cCurrent and all previous launches with the same name\u201d"})," option: Smoke Launch 3, Smoke Launch 1, Smoke Launch 2."]}),"\n",(0,a.jsxs)(n.p,{children:["Launches that will have analyzed if you choose ",(0,a.jsx)(n.strong,{children:"\u201cAll previous launches with the same name\u201d"})," option: Smoke Launch 1, Smoke Launch 2."]}),"\n",(0,a.jsxs)(n.p,{children:["Launches that will have analyzed if you choose ",(0,a.jsx)(n.strong,{children:"\u201cOnly previous launch with the same name\u201d"})," option: Smoke Launch 2."]}),"\n",(0,a.jsxs)(n.p,{children:["Launches that will have analyzed if you choose ",(0,a.jsx)(n.strong,{children:"\u201cOnly current launch\u201d"})," option: Smoke Launch 3."]}),"\n",(0,a.jsx)(n.p,{children:"You can choose those configurations via Project configuration or from the list of actions on All launches view."}),"\n",(0,a.jsx)(n.h3,{id:"defect-assignment-based-on-the-longest-retry",children:"Defect assignment based on the longest retry"}),"\n",(0,a.jsx)(n.p,{children:"ReportPortal allows users to control how the system prioritizes retries for analysis. By default, only the latest retry is considered, but users can also choose to analyze the longest retry \u2014 the one with the most passed nested steps before the first failure."}),"\n",(0,a.jsx)(n.p,{children:'If a test has retries and the test structure contains nested steps, the assignment of defects is determined by the "Defect assignment based on the longest retry" checkbox in the Auto-Analysis settings. The Analyzer applies defect types based on this configuration during manual, auto, or Immediate Auto-Analysis.'}),"\n",(0,a.jsx)(n.admonition,{type:"note",children:(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Permissions:"}),(0,a.jsx)("br",{}),"\nAdmin, Project Manager can modify the setting.",(0,a.jsx)("br",{}),"\nCustomer, Member, Operator can view only."]})}),"\n",(0,a.jsxs)(n.p,{children:["By default, ",(0,a.jsx)(n.strong,{children:"the checkbox is not checked"}),". In this case:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"When a test has retries, ReportPortal sends the logs of the latest retry to the Analyzer."}),"\n"]}),"\n",(0,a.jsx)(t,{src:s(76029),alt:"Defect assignment based on the longest retry checkbox is not checked"}),"\n",(0,a.jsxs)(n.p,{children:["When ",(0,a.jsx)(n.strong,{children:"the checkbox is checked"}),":"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"ReportPortal sends the logs of the longest retry (the retry with the maximum number of passed nested steps before the first failure) to the Analyzer."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"This ensures that defect assignment is based on the most representative retry, not just the most recent one."}),"\n",(0,a.jsx)(t,{src:s(94822),alt:"Defect assignment based on the longest retry checkbox is checked"}),"\n",(0,a.jsx)(n.h3,{id:"removegenerate-opensearch-index",children:"Remove/Generate OpenSearch index"}),"\n",(0,a.jsx)(n.p,{children:"There two possible actions that can be performed under Index in OpenSearch."}),"\n",(0,a.jsxs)(n.p,{children:["You can ",(0,a.jsx)(n.strong,{children:"remove the Index from OpenSearch"})," and all logs with there defect type will be deleted. ML will be set to zero. All data with your investigations will be deleted from the OpenSearch. For creating a new one you could start to investigate test results manually or generate data based on previous results on the project once again."]}),"\n",(0,a.jsx)(n.admonition,{type:"note",children:(0,a.jsx)(n.p,{children:"Your investigations in ReportPortal will not be changed. The operation concerns only OpenSearch base."})}),"\n",(0,a.jsx)(t,{src:"https://youtu.be/4Xhwu7NSeQ4",alt:"Remove Index",type:"video"}),"\n",(0,a.jsxs)(n.p,{children:["Another option, you can ",(0,a.jsx)(n.strong,{children:"generate the Index in OpenSearch"}),". In the case of generation, all data will be removed from OpenSearch and the new one will be generated based on all previous investigations on the project following current analysis settings."]}),"\n",(0,a.jsx)(n.p,{children:"At the end of the process, you will receive a letter with info about the end of the process and with several items that will be appeared in OpenSearch."}),"\n",(0,a.jsx)(n.p,{children:"You can use index generation for several goals. For example, assume two hypothetical situations when index generation can be used:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"by accident you remove the index, but now you want to restore it."}),"\n"]}),"\n",(0,a.jsx)(n.admonition,{type:"note",children:(0,a.jsx)(n.p,{children:"The new base will be generated following logs and settings that are existing on the moment of operating. So index before removing and index after generation can be different."})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["you have changed a parameter ",(0,a.jsx)(n.strong,{children:"Number of log lines"})," for 3.  But your existing index contains logs with value ALL. You can generate a new index, the old index will be removed, and a new one will be generated. Logs in the new index will contain 3 lines;"]}),"\n"]}),"\n",(0,a.jsx)(t,{src:"https://youtu.be/HYvtZmIzfiA",alt:"Generate Index",type:"video"}),"\n",(0,a.jsx)(n.p,{children:"We strongly do not recommend use auto-analysis until the new index will be generated."}),"\n",(0,a.jsx)(n.h3,{id:"manual-analysis",children:"Manual analysis"}),"\n",(0,a.jsx)(n.p,{children:"Analysis can be launched manually. To start the analysis manually, perform the following steps:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:'Navigate to the "Launches" page.'}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:'Select the "Analysis" option from the context menu next to the selected launch name.'}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Choose the scope of previous results on the base of which test items should be auto-analyzed.  The default is the one that is chosen on the setting page, but you can change it manually."}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Via this menu you can choose 3 options unlike on Project Settings:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"All launches;"}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Launches with the same name;"}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Only current launch;"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["Options ",(0,a.jsx)(n.strong,{children:"All launches"})," and ",(0,a.jsx)(n.strong,{children:"Launches with the same name"})," are working the same as on project settings.\nIf you choose ",(0,a.jsx)(n.strong,{children:"Only current launch"}),", the system is analyzing the test items of chosen launch only on a base of already investigated date of this launch."]}),"\n",(0,a.jsxs)(n.ol,{start:"4",children:["\n",(0,a.jsx)(n.li,{children:"Choose which items from launch should be analyzed:"}),"\n"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Only To investigated;"}),"\n",(0,a.jsx)(n.li,{children:"Items analyzed automatically (by AA);"}),"\n",(0,a.jsx)(n.li,{children:"Items analyzed manually;"}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["In case the user chooses ",(0,a.jsx)(n.strong,{children:"Only To investigate items"}),' -  the system is analyzing only items with defect type "To investigate" in the chosen launch;']}),"\n",(0,a.jsxs)(n.p,{children:["In case the user chooses ",(0,a.jsx)(n.strong,{children:"Items analyzed automatically (by AA)"})," - the system is analyzing only items that have been already analyzed by auto-analysis. The results of the previous run of analysis will be set to zero and items will be analyzed once again."]}),"\n",(0,a.jsxs)(n.p,{children:["In case the user chooses ",(0,a.jsx)(n.strong,{children:"Items analyzed manually"})," - the system is analyzing only items that have been already analyzed by the user manually. The results of the previous run of analysis will be set to zero and items will be analyzed once again."]}),"\n",(0,a.jsx)(n.p,{children:"In the case of multi-combination - the system is analyzing results dependence on chosen options."}),"\n",(0,a.jsx)(n.admonition,{type:"note",children:(0,a.jsxs)(n.p,{children:["The Ignore flag is saved. If the item has flag ",(0,a.jsx)(n.strong,{children:"Ignore in AA"}),", it will not be re-analyzed."]})}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsxs)(n.p,{children:["For option ",(0,a.jsx)(n.strong,{children:"Only current launch"})," you can not choose ",(0,a.jsx)(n.em,{children:"Items analyzed automatically (by AA)"})," and ",(0,a.jsx)(n.em,{children:"Items analyzed manually"})," simultaneously."]})}),"\n",(0,a.jsxs)(n.ol,{start:"4",children:["\n",(0,a.jsx)(n.li,{children:'Click the "Analysis" button. Now "Auto-Analysis" will start.'}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:'Any launches with an active analyzing process will be marked with the "Analysis" label.'}),"\n",(0,a.jsxs)(n.admonition,{type:"note",children:[(0,a.jsxs)(n.p,{children:["If a test has retries and the test structure contains nested steps, the assignment of defects is determined by the ",(0,a.jsx)(n.a,{href:"/analysis/AutoAnalysisOfLaunches#defect-assignment-based-on-the-longest-retry",children:'"Defect assignment based on the longest retry" checkbox'})," in the Auto-Analysis settings.",(0,a.jsx)("br",{})]}),(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["If the checkbox is not checked, ReportPortal sends the logs of the latest retry to the Analyzer.",(0,a.jsx)("br",{})]}),"\n",(0,a.jsx)(n.li,{children:"If the checkbox is checked, ReportPortal sends the logs of the longest retry (the retry with the maximum number of passed nested steps before the first failure) to the Analyzer."}),"\n"]})]}),"\n",(0,a.jsx)(t,{src:"https://youtu.be/OmT2exhOdC4",alt:"Auto-Analysis Launched Manually",type:"video"}),"\n",(0,a.jsx)(n.h2,{id:"label-aa",children:"Label AA"}),"\n",(0,a.jsx)(n.p,{children:'When the test item is analyzed by the ReportPortal, a label "AA" is set on the test item on a Step Level. You can filter results with a parameter \u201cAnalysed by RP (AA)\u201d'}),"\n",(0,a.jsx)(t,{src:s(77282),alt:"Label AA"}),"\n",(0,a.jsx)(n.h2,{id:"ignore-in-auto-analysis",children:"Ignore in Auto-Analysis"}),"\n",(0,a.jsx)(n.p,{children:'If you don\'t want to save some test items in OpenSearch, you can "Ignore in Auto-Analysis". For that you can choose this action in \u201cMake decision\u201d modal:'}),"\n",(0,a.jsx)(t,{src:s(5543),alt:"Ignore in Auto-Analysis"}),"\n",(0,a.jsx)(n.p,{children:"Or from the action list for several test items:"}),"\n",(0,a.jsx)(t,{src:s(37068),alt:"Auto-Analysis Ignore Action List"}),"\n",(0,a.jsx)(n.p,{children:"When you choose \u201cIgnore in AA\u201d, logs of the chosen item are removed from the OpenSearch."})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},89392:(e,n,s)=>{s.r(n),s.d(n,{default:()=>t});const t=s.p+"assets/images/BaseForAnalysis-4ce9e9cc5852092aadec6dbf3215c28a.jpg"},5543:(e,n,s)=>{s.r(n),s.d(n,{default:()=>t});const t=s.p+"assets/images/IgnoreInAutoAnalysis1-08467f09060002fdd014f93ef5b82be7.png"},37068:(e,n,s)=>{s.r(n),s.d(n,{default:()=>t});const t=s.p+"assets/images/IgnoreInAutoAnalysis2-46584139c23817753eacc92a32e077dd.png"},77282:(e,n,s)=>{s.r(n),s.d(n,{default:()=>t});const t=s.p+"assets/images/LabelAA-bab20b1a3828766086e9fa5f84a6737a.png"},76029:(e,n,s)=>{s.r(n),s.d(n,{default:()=>t});const t=s.p+"assets/images/RetryLogAnalysis1-27a585eb13bd449bc8fec53553949c28.png"},94822:(e,n,s)=>{s.r(n),s.d(n,{default:()=>t});const t=s.p+"assets/images/RetryLogAnalysis2-87557c773536059d0bd5bfdca5c5195a.png"},28453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>r});var t=s(96540);const a={},i=t.createContext(a);function o(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);