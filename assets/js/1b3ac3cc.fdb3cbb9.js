"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[52398],{31506:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>c,frontMatter:()=>a,metadata:()=>t,toc:()=>p});const t=JSON.parse('{"id":"developers-guides/PluginDevelopersGuide/PluginAPIDevelopersGuide","title":"Plugin API development guide","description":"Introduction","source":"@site/docs/developers-guides/PluginDevelopersGuide/PluginAPIDevelopersGuide.mdx","sourceDirName":"developers-guides/PluginDevelopersGuide","slug":"/developers-guides/PluginDevelopersGuide/PluginAPIDevelopersGuide","permalink":"/docs/developers-guides/PluginDevelopersGuide/PluginAPIDevelopersGuide","draft":false,"unlisted":false,"editUrl":"https://github.com/reportportal/docs/blob/develop/docs/developers-guides/PluginDevelopersGuide/PluginAPIDevelopersGuide.mdx","tags":[],"version":"current","frontMatter":{"sidebar_label":"Plugin API development guide"},"sidebar":"docs","previous":{"title":"Develop a custom import plugin","permalink":"/docs/developers-guides/PluginDevelopersGuide/DevelopACustomImportPlugin"},"next":{"title":"Plugin UI development guide","permalink":"/docs/developers-guides/PluginDevelopersGuide/PluginUIDevelopersGuide"}}');var r=i(74848),o=i(28453);const a={sidebar_label:"Plugin API development guide"},s="Plugin API development guide",l={},p=[{value:"Introduction",id:"introduction",level:2},{value:"How does it work",id:"how-does-it-work",level:2},{value:"Creating your first plugin",id:"creating-your-first-plugin",level:2},{value:"Base plugin configuration",id:"base-plugin-configuration",level:3},{value:"Create extension",id:"create-extension",level:3},{value:"Autowire dependencies",id:"autowire-dependencies",level:3},{value:"Get file command",id:"get-file-command",level:3},{value:"Assemble plugin",id:"assemble-plugin",level:3},{value:"Event listeners",id:"event-listeners",level:3},{value:"Lazy initialization",id:"lazy-initialization",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components},{MediaViewer:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("MediaViewer",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"plugin-api-development-guide",children:"Plugin API development guide"})}),"\n",(0,r.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,r.jsx)(n.p,{children:"ReportPortal as a microservice application had services that integrate with external systems like JIRA or RALLY. These are problems of this\napproach:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"every service will run as a separate application consuming additional amount of resources for environment;"}),"\n",(0,r.jsx)(n.li,{children:"user may not need all the integrations at the moment but need some (or a new one) later, so he should modify deployment configuration\nevery time;"}),"\n",(0,r.jsx)(n.li,{children:"every service modification requires re-deployment."}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["To solve these problems and support dynamic integrations ReportPortal implements plugin system on top\nof ",(0,r.jsx)(n.a,{href:"https://github.com/pf4j/pf4j",children:"PF4J"}),"."]}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsxs)(n.p,{children:["Documentation for the UI plugins can be found ",(0,r.jsx)(n.a,{href:"/docs/developers-guides/PluginDevelopersGuide/PluginUIDevelopersGuide",children:"here"})]})}),"\n",(0,r.jsx)(n.h2,{id:"how-does-it-work",children:"How does it work"}),"\n",(0,r.jsx)(t,{src:i(3637),alt:"Install Plugin"}),"\n",(0,r.jsx)(n.h2,{id:"creating-your-first-plugin",children:"Creating your first plugin"}),"\n",(0,r.jsxs)(n.p,{children:["Result of the following steps can be found here - ",(0,r.jsx)(n.a,{href:"https://github.com/reportportal/plugin-example",children:"Plugin example"}),".\nThis is fully configured and ready-to-use plugin"]}),"\n",(0,r.jsx)(n.h3,{id:"base-plugin-configuration",children:"Base plugin configuration"}),"\n",(0,r.jsx)(n.p,{children:"We configure our build.gradle file as follows:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-groovy",children:"plugins {\n    id \"io.spring.dependency-management\" version \"1.0.9.RELEASE\"\n    id 'java'\n}\n\nrepositories {\n    mavenCentral()\n}\n\ndependencies {\n    implementation 'com.epam.reportportal:plugin-api:5.4.0'\n    annotationProcessor 'com.epam.reportportal:plugin-api:5.4.0'\n}\n\ntask plugin(type: Jar) {\n    getArchiveBaseName().set(\"plugin-${pluginId}\")\n    into('classes') {\n        with jar\n    }\n    into('lib') {\n        from configurations.compile\n    }\n    extension('zip')\n}\n\ntask assemblePlugin(type: Copy) {\n    from plugin\n    into pluginsDir\n}\n\ntask assemblePlugins(type: Copy) {\n    dependsOn subprojects.assemblePlugin\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["This base configuration with ",(0,r.jsx)(n.code,{children:"plugin-api"})," dependency grants access to extension points and core ReportPortal dependencies."]}),"\n",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(n.h3,{id:"create-extension",children:"Create extension"}),"\n",(0,r.jsxs)(n.p,{children:["Firstly we create our plugin representation (we also can override ",(0,r.jsx)(n.code,{children:"start()"})," and ",(0,r.jsx)(n.code,{children:"stop()"})," methods) that will be managed by ",(0,r.jsx)(n.code,{children:"pf4j"})," plugin\nmanager."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"package com.epam.reportportal.extension.example;\n\nimport org.pf4j.Plugin;\nimport org.pf4j.PluginWrapper;\n\npublic class ExamplePlugin extends Plugin {\n\tpublic ExamplePlugin(PluginWrapper wrapper) {\n\t\tsuper(wrapper);\n\t}\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Then we create our plugin entry point. We start with ",(0,r.jsx)(n.code,{children:"ReportPortalExtensionPoint"})," implementation:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'\n@Extension\npublic class ExampleExtension implements ReportPortalExtensionPoint {\n\n\tprivate final Supplier<Map<String, PluginCommand<?>>> pluginCommandMapping = new MemoizingSupplier<>(this::getCommands);\n\n\tpublic ExampleExtension(Map<String, Object> initParams) {\n\n\t}\n\n\t@Override\n\tpublic Map<String, ?> getPluginParams() {\n\t\tMap<String, Object> params = new HashMap<>();\n\t\tparams.put(ALLOWED_COMMANDS, new ArrayList<>(pluginCommandMapping.get().keySet()));\n\t\treturn params;\n\t}\n\n\t@Override\n\tpublic PluginCommand<?> getCommandToExecute(String commandName) {\n\t\treturn pluginCommandMapping.get().get(commandName);\n\t}\n\n\tprivate Map<String, PluginCommand<?>> getCommands() {\n\t\tMap<String, PluginCommand<?>> pluginCommandMapping = new HashMap<>();\n\t\tpluginCommandMapping.put("testConnection", (integration, params) -> true);\n\t\treturn pluginCommandMapping;\n\t}\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["We implement ",(0,r.jsx)(n.code,{children:"getPluginParams()"})," to get list of supported plugin ",(0,r.jsx)(n.code,{children:"commands"})," from the client side. We implement ",(0,r.jsx)(n.code,{children:"getCommandToExecute()"})," to\nget command from mapping to execute. As for now we only have ",(0,r.jsx)(n.code,{children:"testConnection"})," command that implements base command interface:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"public interface PluginCommand<T> {\n\t/**\n\t * Executes plugin command\n\t *\n\t * @param integration Configured ReportPortal integration\n\t * @param params      Plugin Command parameters\n\t * @return Result\n\t */\n\tT executeCommand(Integration integration, Map<String, Object> params);\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Command ",(0,r.jsx)(n.code,{children:"testConnection"})," is mandatory and should either always return ",(0,r.jsx)(n.code,{children:"true"})," or execute logic of connection test with external system."]}),"\n",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(n.h3,{id:"autowire-dependencies",children:"Autowire dependencies"}),"\n",(0,r.jsxs)(n.p,{children:["Being loaded in runtime plugin extension can be handled as ",(0,r.jsx)(n.code,{children:"Spring bean"}),". That's why we can autowire dependencies just as we do in core\napplication:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"\n@Extension\npublic class ExampleExtension implements ReportPortalExtensionPoint {\n  ...\n\t@Autowired\n\tprivate ApplicationContext applicationContext;\n\n\t@Autowired\n\tprivate IntegrationTypeRepository integrationTypeRepository;\n\n\t@Autowired\n\tprivate IntegrationRepository integrationRepository;\n\n\tpublic ExampleExtension(Map<String, Object> initParams) {\n\t}\n  ...\n}\n"})}),"\n",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(n.h3,{id:"get-file-command",children:"Get file command"}),"\n",(0,r.jsxs)(n.p,{children:["We can store in ",(0,r.jsx)(n.code,{children:"resources"})," folder files that can be loaded from the client side later. During plugin installation ",(0,r.jsx)(n.code,{children:"plugin manager"})," provides\ndirectory in the file system to store plugin resources. This directory passed through the constructor (with Map parameter) and can be\naccessed as follows:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'\n@Extension\npublic class ExampleExtension implements ReportPortalExtensionPoint {\n\n\tprivate final String resourcesDir;\n\n\t...\n\n\tpublic ExampleExtension(Map<String, Object> initParams) {\n\t\tresourcesDir = IntegrationTypeProperties.RESOURCES_DIRECTORY.getValue(initParams).map(String::valueOf).orElse("");\n\t}\n\n\t...\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"GetFileCommand"})," accepts ",(0,r.jsx)(n.code,{children:"resourcesDir"})," and ",(0,r.jsx)(n.code,{children:"propertyFile"})," as constructor parameters. Property file should be stored in ",(0,r.jsx)(n.code,{children:"resources"})," folder\nof the plugin. It contains ",(0,r.jsx)(n.em,{children:"key-value"})," mapping that represents files allowed to be loaded from the client side:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-properties",children:"icon=plugin-icon.svg\n"})}),"\n",(0,r.jsxs)(n.p,{children:["We created ",(0,r.jsx)(n.code,{children:"example-binary-data.properties"})," file with these contents and now can access ",(0,r.jsx)(n.code,{children:"plugin-icon.svg"})," file by passing ",(0,r.jsx)(n.code,{children:"icon"})," key\nto ",(0,r.jsx)(n.code,{children:"getFileCommand"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"That's how our extension looks now:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'\n@Extension\npublic class ExampleExtension implements ReportPortalExtensionPoint {\n\n\tpublic static final String BINARY_DATA_PROPERTIES_FILE_ID = "example-binary-data.properties";\n\tprivate final String resourcesDir;\n\n\tprivate final Supplier<Map<String, PluginCommand<?>>> pluginCommandMapping = new MemoizingSupplier<>(this::getCommands);\n\n\t@Autowired\n\tprivate ApplicationContext applicationContext;\n\n\t@Autowired\n\tprivate IntegrationTypeRepository integrationTypeRepository;\n\n\t@Autowired\n\tprivate IntegrationRepository integrationRepository;\n\n\tpublic ExampleExtension(Map<String, Object> initParams) {\n\t\tresourcesDir = IntegrationTypeProperties.RESOURCES_DIRECTORY.getValue(initParams).map(String::valueOf).orElse("");\n\t}\n\n\t@Override\n\tpublic Map<String, ?> getPluginParams() {\n\t\tMap<String, Object> params = new HashMap<>();\n\t\tparams.put(ALLOWED_COMMANDS, new ArrayList<>(pluginCommandMapping.get().keySet()));\n\t\treturn params;\n\t}\n\n\t@Override\n\tpublic PluginCommand<?> getCommandToExecute(String commandName) {\n\t\treturn pluginCommandMapping.get().get(commandName);\n\t}\n\n\tprivate Map<String, PluginCommand<?>> getCommands() {\n\t\tMap<String, PluginCommand<?>> pluginCommandMapping = new HashMap<>();\n\t\tpluginCommandMapping.put("getFile", new GetFileCommand(resourcesDir, BINARY_DATA_PROPERTIES_FILE_ID));\n\t\tpluginCommandMapping.put("testConnection", (integration, params) -> true);\n\t\treturn pluginCommandMapping;\n\t}\n}\n'})}),"\n",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(n.h3,{id:"assemble-plugin",children:"Assemble plugin"}),"\n",(0,r.jsx)(n.p,{children:"Our plugin can be built either as:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"simple jar (without external dependencies) and use dependencies from core application;"}),"\n",(0,r.jsx)(n.li,{children:"shadow jar (with external dependencies) and still use dependencies from core application."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"We should configure plugin jar manifest with mandatory properties:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"id"}),"\n",(0,r.jsx)(n.li,{children:"version"}),"\n",(0,r.jsx)(n.li,{children:"plugin class (class marked with @Extension - our entry point)"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["We should configure ",(0,r.jsx)(n.code,{children:"resource"})," folder contents handling."]}),"\n",(0,r.jsxs)(n.p,{children:["As we load api plugin contents in runtime we can do so with ui contents too. To make it possible we should modify our configuration.\nWe provide new ",(0,r.jsx)(n.code,{children:"ui.gradle"})," config:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-groovy",children:"node {\n    version = '10.14.1'\n    npmVersion = '6.4.1'\n    download = true\n    workDir = file(\"${project.buildDir}/ui\")\n    nodeModulesDir = file(\"${project.rootDir}/ui\")\n}\n\nnpm_run_build {\n    inputs.files fileTree(\"ui/src\")\n    inputs.file 'ui/package.json'\n    inputs.file 'ui/package-lock.json'\n    outputs.dir 'ui/build'\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Load it to the main configuration as a dependency and make some changes to include generated ",(0,r.jsx)(n.code,{children:"main.js"})," file to ",(0,r.jsx)(n.code,{children:"resources"})," folder that\nallows us to load it using ",(0,r.jsx)(n.code,{children:"GetFileCommand"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["That's how our ",(0,r.jsx)(n.code,{children:"build.gradle"})," looks now:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-groovy",children:'import com.github.spotbugs.SpotBugsTask\n\nplugins {\n    id "io.spring.dependency-management" version "1.0.9.RELEASE"\n    id \'java\'\n    id \'com.github.johnrengelman.shadow\' version \'5.2.0\'\n    id "com.moowork.node" version "1.3.1"\n}\n\napply from: \'ui.gradle\'\n\nrepositories {\n    mavenCentral()\n}\n\ndependencies {\n    implementation \'com.epam.reportportal:plugin-api:5.4.0\'\n    annotationProcessor \'com.epam.reportportal:plugin-api:5.4.0\'\n}\n\nartifacts {\n    archives shadowJar\n}\n\nsourceSets {\n    main {\n        resources\n                {\n                    exclude \'**\'\n                }\n    }\n}\n\njar {\n    from("src/main/resources") {\n        into("/resources")\n    }\n    from("ui/build") {\n        into("/resources")\n    }\n    manifest {\n        attributes(\n                "Class-Path": configurations.compile.collect { it.getName() }.join(\' \'),\n                "Plugin-Id": "${pluginId}",\n                "Plugin-Version": "${project.version}",\n                "Plugin-Provider": "Report Portal",\n                "Plugin-Class": "com.epam.reportportal.extension.example.ExamplePlugin",\n                "Plugin-Service": "api"\n        )\n    }\n}\n\nshadowJar {\n    from("src/main/resources") {\n        into("/resources")\n    }\n    from("ui/build") {\n        into("/resources")\n    }\n    configurations = [project.configurations.compile]\n    zip64 true\n    dependencies {\n    }\n}\n\ntask plugin(type: Jar) {\n    getArchiveBaseName().set("plugin-${pluginId}")\n    into(\'classes\') {\n        with jar\n    }\n    into(\'lib\') {\n        from configurations.compile\n    }\n    extension(\'zip\')\n}\n\ntask assemblePlugin(type: Copy) {\n    from plugin\n    into pluginsDir\n}\n\ntask assemblePlugins(type: Copy) {\n    dependsOn subprojects.assemblePlugin\n}\n\ncompileJava.dependsOn npm_run_build\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Now we can just execute ",(0,r.jsx)(n.em,{children:"./gradlew build"})," and get plugin binaries (as jar and as shadowJar) that can be loaded to the application."]}),"\n",(0,r.jsx)(n.h3,{id:"event-listeners",children:"Event listeners"}),"\n",(0,r.jsx)(n.p,{children:"All plugin commands are executed through the core application end-point with mapping:"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"https://host:port/v1/integration/{projectName}/{integrationId}/{command}"})}),"\n",(0,r.jsxs)(n.p,{children:["As we can see ",(0,r.jsx)(n.code,{children:"integrationId"})," is a mandatory parameter that specifies integration to be used in the command execution."]}),"\n",(0,r.jsxs)(n.p,{children:["We can affect logic executed in core application from the plugin by handling predefined set of events. As for now we will use\nmandatory ",(0,r.jsx)(n.code,{children:"PluginLoadedEventHandler"})," as an example."]}),"\n",(0,r.jsxs)(n.p,{children:["This handler creates the very first integration and uses ",(0,r.jsx)(n.code,{children:"PluginInfoProvider"})," to update plugin data in the database."]}),"\n",(0,r.jsxs)(n.p,{children:["To add a new listener we should use ",(0,r.jsx)(n.code,{children:"ApplicationContext"})," after plugin was loaded - so we do it in the method marked by ",(0,r.jsx)(n.code,{children:"@PostConstruct"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Also, we should remove listeners when we unload plugin - so we implement ",(0,r.jsx)(n.code,{children:"DisposableBean"})," interface and provide this logic in the ",(0,r.jsx)(n.code,{children:"preDestroy()"})," method."]}),"\n",(0,r.jsx)(n.p,{children:"That's how our extension looks now:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'\n@Extension\npublic class ExampleExtension implements ReportPortalExtensionPoint, DisposableBean {\n\n\tpublic static final String BINARY_DATA_PROPERTIES_FILE_ID = "example-binary-data.properties";\n\tprivate static final String PLUGIN_ID = "example";\n\tprivate final String resourcesDir;\n\n\tprivate final Supplier<Map<String, PluginCommand<?>>> pluginCommandMapping = new MemoizingSupplier<>(this::getCommands);\n\tprivate final Supplier<ApplicationListener<PluginEvent>> pluginLoadedListenerSupplier;\n\n\t@Autowired\n\tprivate ApplicationContext applicationContext;\n\n\t@Autowired\n\tprivate IntegrationTypeRepository integrationTypeRepository;\n\n\t@Autowired\n\tprivate IntegrationRepository integrationRepository;\n\n\tpublic ExampleExtension(Map<String, Object> initParams) {\n\t\tresourcesDir = IntegrationTypeProperties.RESOURCES_DIRECTORY.getValue(initParams).map(String::valueOf).orElse("");\n\n\t\tpluginLoadedListenerSupplier = new MemoizingSupplier<>(() -> new ExamplePluginEventListener(PLUGIN_ID,\n\t\t\t\tnew PluginEventHandlerFactory(integrationTypeRepository,\n\t\t\t\t\t\tintegrationRepository,\n\t\t\t\t\t\tnew PluginInfoProviderImpl(resourcesDir, BINARY_DATA_PROPERTIES_FILE_ID)\n\t\t\t\t)\n\t\t));\n\t}\n\n\t@Override\n\tpublic Map<String, ?> getPluginParams() {\n\t\tMap<String, Object> params = new HashMap<>();\n\t\tparams.put(ALLOWED_COMMANDS, new ArrayList<>(pluginCommandMapping.get().keySet()));\n\t\treturn params;\n\t}\n\n\t@Override\n\tpublic PluginCommand<?> getCommandToExecute(String commandName) {\n\t\treturn pluginCommandMapping.get().get(commandName);\n\t}\n\n\t@PostConstruct\n\tpublic void createIntegration() throws IOException {\n\t\tinitListeners();\n\t}\n\n\tprivate void initListeners() {\n\t\tApplicationEventMulticaster applicationEventMulticaster = applicationContext.getBean(AbstractApplicationContext.APPLICATION_EVENT_MULTICASTER_BEAN_NAME,\n\t\t\t\tApplicationEventMulticaster.class\n\t\t);\n\t\tapplicationEventMulticaster.addApplicationListener(pluginLoadedListenerSupplier.get());\n\t}\n\n\t@Override\n\tpublic void destroy() {\n\t\tremoveListeners();\n\t}\n\n\tprivate void removeListeners() {\n\t\tApplicationEventMulticaster applicationEventMulticaster = applicationContext.getBean(AbstractApplicationContext.APPLICATION_EVENT_MULTICASTER_BEAN_NAME,\n\t\t\t\tApplicationEventMulticaster.class\n\t\t);\n\t\tapplicationEventMulticaster.removeApplicationListener(pluginLoadedListenerSupplier.get());\n\t}\n\n\tprivate Map<String, PluginCommand<?>> getCommands() {\n\t\tMap<String, PluginCommand<?>> pluginCommandMapping = new HashMap<>();\n\t\tpluginCommandMapping.put("getFile", new GetFileCommand(resourcesDir, BINARY_DATA_PROPERTIES_FILE_ID));\n\t\tpluginCommandMapping.put("testConnection", (integration, params) -> true);\n\t\treturn pluginCommandMapping;\n\t}\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"lazy-initialization",children:"Lazy initialization"}),"\n",(0,r.jsxs)(n.p,{children:["All plugin components that relies on ",(0,r.jsx)(n.code,{children:"@Autowired"})," dependencies should be loaded lazily using ",(0,r.jsx)(n.code,{children:"MemoizingSupplier"})," or another lazy-load mechanism.\nThis is the restriction of plugin installation flow:"]}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsxs)(n.p,{children:["We create extension object using constructor and only then we autowire dependencies. If we don't use lazy initialization - all objects created in the constructor will be created with ",(0,r.jsx)(n.code,{children:"NULL"})," objects that were marked as ",(0,r.jsx)(n.code,{children:"@Autowired"})]})})]})}function c(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},3637:(e,n,i)=>{i.r(n),i.d(n,{default:()=>t});const t=i.p+"assets/images/InstallPlugin-a1133a05f643c6e301c206898d0afc16.png"}}]);